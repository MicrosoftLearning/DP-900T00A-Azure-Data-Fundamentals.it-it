---
ms.openlocfilehash: 334cc21b44dad92ee91fd1f8a2aaf91f242cea2e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051803"
---
# <a name="qs-supversion-badge21sup"></a>qs <sup>[![Badge della versione][2]][1]</sup>

[![Stato della compilazione][3]][4]
[![stato delle dipendenze][5]][6]
[![stato delle dipendenze di sviluppo][7]][8]
[![Licenza][license-image]][license-url]
[![Download][downloads-image]][downloads-url]

[![badge npm][11]][1]

Libreria per l'analisi di stringhe di query e la conversione in stringa con l'aggiunta di alcune funzionalità di sicurezza.

Responsabile della manutenzione: [Jordan Harband](https://github.com/ljharb)

Il modulo **qs** è stato originariamente creato e gestito da [TJ Holowaychuk](https://github.com/visionmedia/node-querystring).

## <a name="usage"></a>Utilizzo

```javascript
var qs = require('qs');
var assert = require('assert');

var obj = qs.parse('a=c');
assert.deepEqual(obj, { a: 'c' });

var str = qs.stringify(obj);
assert.equal(str, 'a=c');
```

### <a name="parsing-objects"></a>Analisi degli oggetti

[](#preventEval)
```javascript
qs.parse(string, [options]);
```

**qs** consente di creare oggetti annidati all'interno delle stringhe di query, racchiudendo il nome delle sottochiavi tra parentesi quadre `[]`.
Ad esempio, la stringa `'foo[bar]=baz'` viene convertita in:

```javascript
assert.deepEqual(qs.parse('foo[bar]=baz'), {
    foo: {
        bar: 'baz'
    }
});
```

Quando si usa l'opzione `plainObjects` il valore analizzato viene restituito come oggetto Null, creato tramite `Object.create(null)` e pertanto è necessario tenere presente che i metodi di prototipo non saranno applicabili e un utente potrebbe impostare tali nomi su qualsiasi valore:

```javascript
var nullObject = qs.parse('a[hasOwnProperty]=b', { plainObjects: true });
assert.deepEqual(nullObject, { a: { hasOwnProperty: 'b' } });
```

Per impostazione predefinita, i parametri che causerebbero la sovrascrittura delle proprietà nel prototipo dell'oggetto vengono ignorati. Se si desidera mantenere i dati da tali campi, usare `plainObjects` come indicato in precedenza o impostare `allowPrototypes` su `true`, in modo che sia consentito all'input dell'utente di sovrascrivere tali proprietà. *AVVISO* In genere non è consigliabile abilitare questa opzione perché può causare problemi quando si tenta di usare le proprietà sovrascritte. Prestare sempre attenzione con questa opzione.

```javascript
var protoObject = qs.parse('a[hasOwnProperty]=b', { allowPrototypes: true });
assert.deepEqual(protoObject, { a: { hasOwnProperty: 'b' } });
```

Anche le stringhe con codifica URI funzionano:

```javascript
assert.deepEqual(qs.parse('a%5Bb%5D=c'), {
    a: { b: 'c' }
});
```

È anche possibile annidare gli oggetti, ad esempio `'foo[bar][baz]=foobarbaz'`:

```javascript
assert.deepEqual(qs.parse('foo[bar][baz]=foobarbaz'), {
    foo: {
        bar: {
            baz: 'foobarbaz'
        }
    }
});
```

Per impostazione predefinita, quando si annidano oggetti **qs** analizza solo fino a 5 figli in profondità. Ciò significa che se si tenta di analizzare una stringa come `'a[b][c][d][e][f][g][h][i]=j'` l'oggetto risultante sarà:

```javascript
var expected = {
    a: {
        b: {
            c: {
                d: {
                    e: {
                        f: {
                            '[g][h][i]': 'j'
                        }
                    }
                }
            }
        }
    }
};
var string = 'a[b][c][d][e][f][g][h][i]=j';
assert.deepEqual(qs.parse(string), expected);
```

È possibile eseguire l'override di questa profondità passando un'opzione `depth` a `qs.parse(string, [options])`:

```javascript
var deep = qs.parse('a[b][c][d][e][f][g][h][i]=j', { depth: 1 });
assert.deepEqual(deep, { a: { b: { '[c][d][e][f][g][h][i]': 'j' } } });
```

Il limite di profondità consente di mitigare l'abuso quando **qs** viene usato per analizzare l'input dell'utente ed è consigliabile mantenerlo entro un numero ragionevolmente ridotto.

Per motivi simili, **qs** per impostazione predefinita analizza solo al massimo 1000 parametri. È possibile eseguire l'override di questo limite passando un'opzione `parameterLimit`:

```javascript
var limited = qs.parse('a=b&c=d', { parameterLimit: 1 });
assert.deepEqual(limited, { a: 'b' });
```

Per ignorare il punto interrogativo iniziale, usare `ignoreQueryPrefix`:

```javascript
var prefixed = qs.parse('?a=b&c=d', { ignoreQueryPrefix: true });
assert.deepEqual(prefixed, { a: 'b', c: 'd' });
```

È anche possibile passare un delimitatore facoltativo:

```javascript
var delimited = qs.parse('a=b;c=d', { delimiter: ';' });
assert.deepEqual(delimited, { a: 'b', c: 'd' });
```

Anche i delimitatori possono essere un'espressione regolare:

```javascript
var regexed = qs.parse('a=b;c=d,e=f', { delimiter: /[;,]/ });
assert.deepEqual(regexed, { a: 'b', c: 'd', e: 'f' });
```

L'opzione `allowDots` può essere usata per abilitare la notazione con punto:

```javascript
var withDots = qs.parse('a.b=c', { allowDots: true });
assert.deepEqual(withDots, { a: { b: 'c' } });
```

Se è necessario gestire browser o servizi legacy, è disponibile anche il supporto per la decodifica degli ottetti con codifica percentuale nel formato ISO-8859-1:

```javascript
var oldCharset = qs.parse('a=%A7', { charset: 'iso-8859-1' });
assert.deepEqual(oldCharset, { a: '§' });
```

Alcuni servizi aggiungono un valore iniziale `utf8=✓` ai moduli in modo che le versioni precedenti di Internet Explorer inviino con maggiore probabilità il modulo come UTF-8. Inoltre, il server può controllare il valore per individuare codifiche sbagliate del carattere di segno di spunta e rilevare che una stringa di query o un corpo `application/x-www-form-urlencoded` *non* è stato inviato come UTF-8, ad esempio se il modulo aveva un parametro `accept-charset` o la pagina contenitore aveva un set di caratteri diverso.

**qs** supporta questo meccanismo tramite l'opzione `charsetSentinel`.
Se specificato, il parametro `utf8` verrà omesso dall'oggetto restituito. Verrà usato per passare alla modalità `iso-8859-1`/`utf-8` a seconda del modo in cui è codificato il segno di spunta.

**Importante**: quando si specifica sia l'opzione `charset` che l'opzione `charsetSentinel`, l'oggetto `charset` verrà sottoposto a override quando la richiesta contiene un `utf8` parametro da cui è possibile dedurre il charset effettivo. In questo senso, `charset` si comporterà come charset predefinito anziché come charset autorevole.

```javascript
var detectedAsUtf8 = qs.parse('utf8=%E2%9C%93&a=%C3%B8', {
    charset: 'iso-8859-1',
    charsetSentinel: true
});
assert.deepEqual(detectedAsUtf8, { a: 'ø' });

// Browsers encode the checkmark as &#10003; when submitting as iso-8859-1:
var detectedAsIso8859_1 = qs.parse('utf8=%26%2310003%3B&a=%F8', {
    charset: 'utf-8',
    charsetSentinel: true
});
assert.deepEqual(detectedAsIso8859_1, { a: 'ø' });
```

Se si vuole decodificare la sintassi `&#...;` nel carattere effettivo, è possibile specificare anche l'opzione `interpretNumericEntities`:

```javascript
var detectedAsIso8859_1 = qs.parse('a=%26%239786%3B', {
    charset: 'iso-8859-1',
    interpretNumericEntities: true
});
assert.deepEqual(detectedAsIso8859_1, { a: '☺' });
```

Funziona anche quando il charset è stato rilevato in modalità `charsetSentinel`.

### <a name="parsing-arrays"></a>Analisi di matrici

**qs** può anche analizzare le matrici usando una notazione `[]` simile:

```javascript
var withArray = qs.parse('a[]=b&a[]=c');
assert.deepEqual(withArray, { a: ['b', 'c'] });
```

È anche possibile specificare un indice:

```javascript
var withIndexes = qs.parse('a[1]=c&a[0]=b');
assert.deepEqual(withIndexes, { a: ['b', 'c'] });
```

Si noti che l'unica differenza tra un indice in una matrice e una chiave in un oggetto è che il valore tra parentesi quadre deve essere un numero per creare una matrice. Quando si creano matrici con indici specifici, **qs** compatta una matrice sparse mantenendo solo i valori esistenti e rispettandone l'ordine:

```javascript
var noSparse = qs.parse('a[1]=b&a[15]=c');
assert.deepEqual(noSparse, { a: ['b', 'c'] });
```

È anche possibile usare l'opzione `allowSparse` per analizzare le matrici sparse:

```javascript
var sparseArray = qs.parse('a[1]=2&a[3]=5', { allowSparse: true });
assert.deepEqual(sparseArray, { a: [, '2', , '5'] });
```

Si noti che anche una stringa vuota è un valore e verrà mantenuta:

```javascript
var withEmptyString = qs.parse('a[]=&a[]=b');
assert.deepEqual(withEmptyString, { a: ['', 'b'] });

var withIndexedEmptyString = qs.parse('a[0]=b&a[1]=&a[2]=c');
assert.deepEqual(withIndexedEmptyString, { a: ['b', '', 'c'] });
```

**qs** limiterà anche la specifica di indici in una matrice a un indice massimo di `20`. Qualsiasi membro della matrice con un indice maggiore di `20` verrà invece convertito in un oggetto con l'indice come chiave. Ciò è necessario per gestire i casi in cui qualcuno invia `a[999999999]`, ad esempio, e sarà richiesta una quantità di tempo significativo per eseguire l'iterazione su questa enorme matrice.

```javascript
var withMaxIndex = qs.parse('a[100]=b');
assert.deepEqual(withMaxIndex, { a: { '100': 'b' } });
```

Questo limite può essere modificato passando un'opzione `arrayLimit`:

```javascript
var withArrayLimit = qs.parse('a[1]=b', { arrayLimit: 0 });
assert.deepEqual(withArrayLimit, { a: { '1': 'b' } });
```

Per disabilitare del tutto l'analisi della matrice, impostare `parseArrays` su `false`.

```javascript
var noParsingArrays = qs.parse('a[]=b', { parseArrays: false });
assert.deepEqual(noParsingArrays, { a: { '0': 'b' } });
```

Se si usano notazioni miste, **qs** unirà i due elementi in un oggetto:

```javascript
var mixedNotation = qs.parse('a[0]=b&a[b]=c');
assert.deepEqual(mixedNotation, { a: { '0': 'b', b: 'c' } });
```

È anche possibile creare matrici di oggetti:

```javascript
var arraysOfObjects = qs.parse('a[][b]=c');
assert.deepEqual(arraysOfObjects, { a: [{ b: 'c' }] });
```

Alcune persone usano la virgola per unire la matrice e **qs** può analizzarla:
```javascript
var arraysOfObjects = qs.parse('a=b,c', { comma: true })
assert.deepEqual(arraysOfObjects, { a: ['b', 'c'] })
```
(_non è possibile convertire oggetti annidati, ad esempio `a={b:1},{c:d}`_ )

### <a name="stringifying"></a>Conversione in stringa

[](#preventEval)
```javascript
qs.stringify(object, [options]);
```

Quando si esegue una conversione in stringa, **qs** applica per impostazione predefinita la codifica URI all'output. Gli oggetti vengono converti in stringa come previsto:

```javascript
assert.equal(qs.stringify({ a: 'b' }), 'a=b');
assert.equal(qs.stringify({ a: { b: 'c' } }), 'a%5Bb%5D=c');
```

Questa codifica può essere disabilitata impostando l'opzione `encode` su `false`:

```javascript
var unencoded = qs.stringify({ a: { b: 'c' } }, { encode: false });
assert.equal(unencoded, 'a[b]=c');
```

La codifica può essere disabilitata per le chiavi impostando l'opzione `encodeValuesOnly` su `true`:
```javascript
var encodedValues = qs.stringify(
    { a: 'b', c: ['d', 'e=f'], f: [['g'], ['h']] },
    { encodeValuesOnly: true }
);
assert.equal(encodedValues,'a=b&c[0]=d&c[1]=e%3Df&f[0][0]=g&f[1][0]=h');
```

Questa codifica può anche essere sostituita con un metodo di codifica personalizzata impostato come opzione `encoder`:

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str) {
    // Passed in values `a`, `b`, `c`
    return // Return encoded string
}})
```

_(Nota: l'opzione `encoder` non è applicabile se `encode` è `false`)_

Analogamente all'opzione `encoder` esiste un'opzione `decoder` per `parse` per eseguire l'override della decodifica delle proprietà e dei valori:

```javascript
var decoded = qs.parse('x=z', { decoder: function (str) {
    // Passed in values `x`, `z`
    return // Return decoded string
}})
```

È possibile codificare chiavi e valori con una logica diversa usando l'argomento di tipo fornito al codificatore:

```javascript
var encoded = qs.stringify({ a: { b: 'c' } }, { encoder: function (str, defaultEncoder, charset, type) {
    if (type === 'key') {
        return // Encoded key
    } else if (type === 'value') {
        return // Encoded value
    }
}})
```

L'argomento di tipo viene fornito anche al decodificatore:

```javascript
var decoded = qs.parse('x=z', { decoder: function (str, defaultDecoder, charset, type) {
    if (type === 'key') {
        return // Decoded key
    } else if (type === 'value') {
        return // Decoded value
    }
}})
```

Gli esempi oltre a questo punto verranno visualizzati come se l'output non fosse codificato come URI per chiarezza. Si noti che ai valori restituiti in questi casi *verrà applicata* la codifica URI durante l'utilizzo reale.

Quando le matrici vengono convertite in stringa, per impostazione predefinita vengono assegnati indici espliciti:

```javascript
qs.stringify({ a: ['b', 'c', 'd'] });
// 'a[0]=b&a[1]=c&a[2]=d'
```

È possibile eseguire l'override di questa impostazione impostando l'opzione `indices` su `false`:

```javascript
qs.stringify({ a: ['b', 'c', 'd'] }, { indices: false });
// 'a=b&a=c&a=d'
```

È possibile usare l'opzione `arrayFormat` per specificare il formato della matrice di output:

```javascript
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'indices' })
// 'a[0]=b&a[1]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'brackets' })
// 'a[]=b&a[]=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'repeat' })
// 'a=b&a=c'
qs.stringify({ a: ['b', 'c'] }, { arrayFormat: 'comma' })
// 'a=b,c'
```

Quando gli oggetti vengono convertiti in stringa, per impostazione predefinita usano la notazione con parentesi quadre:

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } });
// 'a[b][c]=d&a[b][e]=f'
```

È possibile eseguire l'override di questa notazione per usare la notazione con punto impostando l'opzione `allowDots` su `true`:

```javascript
qs.stringify({ a: { b: { c: 'd', e: 'f' } } }, { allowDots: true });
// 'a.b.c=d&a.b.e=f'
```

Le stringhe vuote e i valori Null ometteranno il valore, ma il segno di uguale (=) rimane:

```javascript
assert.equal(qs.stringify({ a: '' }), 'a=');
```

La chiave senza valori (ad esempio un oggetto vuoto o una matrice) non restituirà nulla:

```javascript
assert.equal(qs.stringify({ a: [] }), '');
assert.equal(qs.stringify({ a: {} }), '');
assert.equal(qs.stringify({ a: [{}] }), '');
assert.equal(qs.stringify({ a: { b: []} }), '');
assert.equal(qs.stringify({ a: { b: {}} }), '');
```

Le proprietà impostate su `undefined` verranno omesse interamente:

```javascript
assert.equal(qs.stringify({ a: null, b: undefined }), 'a=');
```

La stringa di query può essere facoltativamente preceduta da un punto interrogativo:

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { addQueryPrefix: true }), '?a=b&c=d');
```

Il delimitatore può essere sottoposto a override anche con stringify:

```javascript
assert.equal(qs.stringify({ a: 'b', c: 'd' }, { delimiter: ';' }), 'a=b;c=d');
```

Se si vuole eseguire solo l'override della serializzazione degli oggetti `Date`, è possibile specificare un'opzione `serializeDate`:

```javascript
var date = new Date(7);
assert.equal(qs.stringify({ a: date }), 'a=1970-01-01T00:00:00.007Z'.replace(/:/g, '%3A'));
assert.equal(
    qs.stringify({ a: date }, { serializeDate: function (d) { return d.getTime(); } }),
    'a=7'
);
```

È possibile usare l'opzione `sort` per influire sull'ordine delle chiavi dei parametri:

```javascript
function alphabeticalSort(a, b) {
    return a.localeCompare(b);
}
assert.equal(qs.stringify({ a: 'c', z: 'y', b : 'f' }, { sort: alphabeticalSort }), 'a=c&b=f&z=y');
```

Infine, è possibile usare l'opzione `filter` per limitare le chiavi che verranno incluse nell'output convertito in stringa.
Se si passa una funzione, verrà chiamata per ogni chiave per ottenere il valore sostitutivo. Se invece si passa una matrice, verrà usata per selezionare le proprietà e gli indici della matrice per la conversione in stringa:

```javascript
function filterFunc(prefix, value) {
    if (prefix == 'b') {
        // Return an `undefined` value to omit a property.
        return;
    }
    if (prefix == 'e[f]') {
        return value.getTime();
    }
    if (prefix == 'e[g][0]') {
        return value * 2;
    }
    return value;
}
qs.stringify({ a: 'b', c: 'd', e: { f: new Date(123), g: [2] } }, { filter: filterFunc });
// 'a=b&c=d&e[f]=123&e[g][0]=4'
qs.stringify({ a: 'b', c: 'd', e: 'f' }, { filter: ['a', 'e'] });
// 'a=b&e=f'
qs.stringify({ a: ['b', 'c', 'd'], e: 'f' }, { filter: ['a', 0, 2] });
// 'a[0]=b&a[2]=d'
```

### <a name="handling-of-null-values"></a>Gestione dei valori `null`

Per impostazione predefinita, i valori `null` vengono gestiti come stringhe vuote:

```javascript
var withNull = qs.stringify({ a: null, b: '' });
assert.equal(withNull, 'a=&b=');
```

L'analisi non distingue tra i parametri con e senza segno di uguale. Entrambi vengono convertiti in stringhe vuote.

```javascript
var equalsInsensitive = qs.parse('a&b=');
assert.deepEqual(equalsInsensitive, { a: '', b: '' });
```

Per distinguere tra valori `null` e stringhe vuote, usare il flag `strictNullHandling`. Nella stringa risultante i valori `null` non hanno alcun segno `=`:

```javascript
var strictNull = qs.stringify({ a: null, b: '' }, { strictNullHandling: true });
assert.equal(strictNull, 'a&b=');
```

Per analizzare i valori senza `=` in modo da gestirli come `null` usare il flag `strictNullHandling`:

```javascript
var parsedStrictNull = qs.parse('a&b=', { strictNullHandling: true });
assert.deepEqual(parsedStrictNull, { a: null, b: '' });
```

Per evitare del tutto il rendering delle chiavi con valori `null`, usare il flag `skipNulls`:

```javascript
var nullsSkipped = qs.stringify({ a: 'b', c: null}, { skipNulls: true });
assert.equal(nullsSkipped, 'a=b');
```

Se si comunica con i sistemi legacy, è possibile passare a `iso-8859-1` usando l'opzione `charset`:

```javascript
var iso = qs.stringify({ æ: 'æ' }, { charset: 'iso-8859-1' });
assert.equal(iso, '%E6=%E6');
```

I caratteri che non esistono in `iso-8859-1` verranno convertiti in entità numeriche, in modo simile a quanto fanno i browser:

```javascript
var numeric = qs.stringify({ a: '☺' }, { charset: 'iso-8859-1' });
assert.equal(numeric, 'a=%26%239786%3B');
```

È possibile usare l'opzione `charsetSentinel` per annunciare il carattere includendo un parametro `utf8=✓` con la codifica appropriata per il segno di spunta, in modo analogo al funzionamento di Ruby on Rails e altri framework quando si inviano moduli.

```javascript
var sentinel = qs.stringify({ a: '☺' }, { charsetSentinel: true });
assert.equal(sentinel, 'utf8=%E2%9C%93&a=%E2%98%BA');

var isoSentinel = qs.stringify({ a: 'æ' }, { charsetSentinel: true, charset: 'iso-8859-1' });
assert.equal(isoSentinel, 'utf8=%26%2310003%3B&a=%E6');
```

### <a name="dealing-with-special-character-sets"></a>Gestione di set di caratteri speciali

Per impostazione predefinita, la codifica e la decodifica dei caratteri viene eseguita in `utf-8` ed è anche incluso il supporto di `iso-8859-1` tramite il parametro `charset`.

Se si desidera codificare stringhe di query con un set di caratteri diverso, ad esempio [Shift JIS](https://en.wikipedia.org/wiki/Shift_JIS), è possibile usare la libreria [`qs-iconv`](https://github.com/martinheidegger/qs-iconv):

```javascript
var encoder = require('qs-iconv/encoder')('shift_jis');
var shiftJISEncoded = qs.stringify({ a: 'こんにちは！' }, { encoder: encoder });
assert.equal(shiftJISEncoded, 'a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I');
```

Questo metodo funziona anche per decodificare le stringhe di query:

```javascript
var decoder = require('qs-iconv/decoder')('shift_jis');
var obj = qs.parse('a=%82%B1%82%F1%82%C9%82%BF%82%CD%81I', { decoder: decoder });
assert.deepEqual(obj, { a: 'こんにちは！' });
```

### <a name="rfc-3986-and-rfc-1738-space-encoding"></a>Codifica dello spazio RFC 3986 e RFC 1738

La codifica RFC 3986 viene usata come impostazione predefinita e codifica ' ' come *%20*, compatibile con le versioni precedenti.
L'output può essere allo stesso tempo convertito in stringa, come da RFC 1738 con ' ' uguale a '+'.

```
assert.equal(qs.stringify({ a: 'b c' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC3986' }), 'a=b%20c');
assert.equal(qs.stringify({ a: 'b c' }, { format : 'RFC1738' }), 'a=b+c');
```

## <a name="security"></a>Sicurezza

Inviare un messaggio di posta elettronica a [@ljharb](https://github.com/ljharb) o visitare il sito https://tidelift.com/security se si deve segnalare una potenziale vulnerabilità di sicurezza.

## <a name="qs-for-enterprise"></a>Modulo qs per le aziende

Disponibile come parte della sottoscrizione Tidelift

I gestori di qs e migliaia di altri pacchetti usano Tidelift per fornire supporto commerciale e manutenzione per le dipendenze open source usate per compilare le applicazioni. È possibile risparmiare tempo, ridurre i rischi e migliorare l'integrità del codice, pagando i gestori delle dipendenze esatte usate. [Altre informazioni.](https://tidelift.com/subscription/pkg/npm-qs?utm_source=npm-qs&utm_medium=referral&utm_campaign=enterprise&utm_term=repo)

[1]: https://npmjs.org/package/qs
[2]: http://versionbadg.es/ljharb/qs.svg
[3]: https://api.travis-ci.org/ljharb/qs.svg
[4]: https://travis-ci.org/ljharb/qs
[5]: https://david-dm.org/ljharb/qs.svg
[6]: https://david-dm.org/ljharb/qs
[7]: https://david-dm.org/ljharb/qs/dev-status.svg
[8]: https://david-dm.org/ljharb/qs?type=dev
[9]: https://ci.testling.com/ljharb/qs.png
[10]: https://ci.testling.com/ljharb/qs
[11]: https://nodei.co/npm/qs.png?downloads=true&stars=true
[license-image]: http://img.shields.io/npm/l/qs.svg
[license-url]: LICENSE
[downloads-image]: http://img.shields.io/npm/dm/qs.svg
[downloads-url]: http://npm-stat.com/charts.html?package=qs
