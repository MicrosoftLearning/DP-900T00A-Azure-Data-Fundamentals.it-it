---
ms.openlocfilehash: 6e78f9de8f21b6501e007e86f631942016f041dc
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051260"
---
# <a name="jsbi--pure-javascript-bigints-build-statushttpstravis-cicomgooglechromelabsjsbi-jsbi-on-npmhttpswwwnpmjscompackagejsbi"></a>JSBI, pure-JavaScript BigInt [![Stato della compilazione](https://travis-ci.com/GoogleChromeLabs/jsbi.svg?branch=main)](https://travis-ci.com/GoogleChromeLabs/jsbi) [![jsbi su npm](https://img.shields.io/npm/v/jsbi)](https://www.npmjs.com/package/jsbi)

JSBI è un'implementazione pure-JavaScript della [proposta BigInt ECMAScript](https://tc39.es/proposal-bigint/), ufficialmente entrata a far parte del linguaggio JavaScript in ES2020.

## <a name="installation"></a>Installazione

```sh
npm install jsbi --save
```

## <a name="usage"></a>Utilizzo

```js
import JSBI from './jsbi.mjs';

const max = JSBI.BigInt(Number.MAX_SAFE_INTEGER);
console.log(String(max));
// → '9007199254740991'
const other = JSBI.BigInt('2');
const result = JSBI.add(max, other);
console.log(String(result));
// → '9007199254740993'
```

Nota: chiamare `toString` in modo esplicito in tutte le istanze di `JSBI` quando si esegue `console.log()` per visualizzarne la rappresentazione numerica (ad esempio `String(max)` o `max.toString()`). Senza (ad esempio `console.log(max)`), viene invece visualizzato l'oggetto che rappresenta il valore.

Usare [babel-plug-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) per eseguire il transpile del codice JSBI nel codice BigInt nativo.

Per ulteriori informazioni, vedere le istruzioni dettagliate riportate di seguito.

## <a name="why"></a>Perché?

[I BigInt nativi sono già presenti](https://v8.dev/features/bigint) nei browser moderni (al momento della stesura di questo documento, Google Chrome 67+, Opera 54+, Firefox 68+) e Node.js (v10.4+) e se ne prevede l'aggiunta in altri browser in futuro. Ciò significa che non è ancora possibile usarli se si vuole che il codice venga eseguito ovunque.

Per usare i BigInt nel codice, attualmente è necessaria una libreria. Ma c'è una difficoltà: la proposta BigInt modifica il comportamento degli operatori (come `+`, `>=` e così via) per lavorare sui BigInt. È impossibile eseguire direttamente il polyfill su queste modifiche e, nella maggior parte dei casi, è anche impossibile eseguire il transpile del codice BigInt nel codice di fallback usando Babel o strumenti simili. Il motivo è che un transpile di questo tipo dovrebbe sostituire ogni singolo operatore del programma con una chiamata a una funzione che esegue controlli sul tipo dei relativi input, con un deterioramento inaccettabile delle prestazioni.

La soluzione consiste nell'eseguire l'operazione inversa: scrivere codice usando la sintassi di una libreria ed [eseguirne il transpile nel codice BigInt nativo](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint), se disponibile. JSBI è progettato esattamente per questo scopo: fornisce un'implementazione "polyfill" di BigInt che si comporta esattamente come i BigInt in arrivo, ma con una sintassi attualmente compatibile con tutti i browser.

Vantaggi rispetto ad altre librerie big integer esistenti:

- Si comporta esattamente come i BigInt nativi prossimamente disponibili, quindi per eseguirvi la migrazione è possibile aggiornare [meccanicamente](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) la sintassi del codice, senza doverne riprogettare la logica.
- Forte attenzione alle prestazioni. In media, JSBI offre prestazioni simili all'implementazione nativa attualmente disponibile in Google Chrome.

## <a name="how"></a>Come si procede?

Ad eccezione delle differenze meccaniche nella sintassi, l'uso di JSBI-BigInt è identico all'[uso di BigInt nativo](https://developers.google.com/web/updates/2018/05/bigint). Alcuni elementi hanno anche un aspetto simile, una volta sostituito `BigInt` con `JSBI.BigInt`:

| Operazione            | BigInt nativo          | JSBI                     |
| -------------------- | ----------------------- | ------------------------ |
| Creazione da stringa | `a = BigInt('456')`     | `a = JSBI.BigInt('456')` |
| Creazione da numero | `a = BigInt(789)`       | `a = JSBI.BigInt(789)`   |
| Conversione in stringa | `a.toString(radix)`     | `a.toString(radix)`      |
| Conversione in numero | `Number(a)`             | `JSBI.toNumber(a)`       |
| Troncamento           | `BigInt.asIntN(64, a)`  | `JSBI.asIntN(64, a)`     |
|                      | `BigInt.asUintN(64, a)` | `JSBI.asUintN(64, a)`    |
| Verifica del tipo           | `typeof a === 'bigint'` | `a instanceof JSBI`      |

La maggior parte degli operatori viene sostituita da chiamate a un metodo:

| Operazione                   | BigInt nativo | JSBI                              |
| --------------------------- | -------------- | --------------------------------- |
| Addizione                    | `c = a + b`    | `c = JSBI.add(a, b)`              |
| Sottrazione                 | `c = a - b`    | `c = JSBI.subtract(a, b)`         |
| Moltiplicazione              | `c = a * b`    | `c = JSBI.multiply(a, b)`         |
| Divisione                    | `c = a / b`    | `c = JSBI.divide(a, b)`           |
| Resto                   | `c = a % b`    | `c = JSBI.remainder(a, b)`        |
| Elevamento a potenza              | `c = a ** b`   | `c = JSBI.exponentiate(a, b)`     |
| Negazione                    | `b = -a`       | `b = JSBI.unaryMinus(a)`          |
| Negazione bit per bit            | `b = ~a`       | `b = JSBI.bitwiseNot(a)`          |
| Spostamento a sinistra               | `c = a << b`   | `c = JSBI.leftShift(a, b)`        |
| Spostamento a destra              | `c = a >> b`   | `c = JSBI.signedRightShift(a, b)` |
| AND bit per bit               | `c = a & b`    | `c = JSBI.bitwiseAnd(a, b)`       |
| OR bit per bit                | `c = a \| b`   | `c = JSBI.bitwiseOr(a, b)`        |
| XOR bit per bit               | `c = a ^ b`    | `c = JSBI.bitwiseXor(a, b)`       |
| Confronto con altri BigInt | `a === b`      | `JSBI.equal(a, b)`                |
|                             | `a !== b`      | `JSBI.notEqual(a, b)`             |
|                             | `a < b`        | `JSBI.lessThan(a, b)`             |
|                             | `a <= b`       | `JSBI.lessThanOrEqual(a, b)`      |
|                             | `a > b`        | `JSBI.greaterThan(a, b)`          |
|                             | `a >= b`       | `JSBI.greaterThanOrEqual(a, b)`   |

Le funzioni riportate sopra operano solo su BigInt. Non eseguono controlli sul tipo nell'implementazione corrente, perché ritenuti inutili. Il tentativo di chiamarli con altri input può generare errori "interessanti".

Alcune operazioni sono particolarmente interessanti quando si assegnano input di tipo misto, ad esempio il confronto di un BigInt con un numero o la concatenazione di una stringa con un BigInt. Vengono implementate come funzioni statiche che prendono il nome dai rispettivi operatori nativi:

| Operazione                       | BigInt nativo | JSBI             |
| ------------------------------- | -------------- | ---------------- |
| Confronto di uguaglianza astratta    | `x == y`       | `JSBI.EQ(x, y)`  |
| "Diverso da" generico             | `x != y`       | `JSBI.NE(x, y)`  |
| "Minore di" generico             | `x < y`        | `JSBI.LT(x, y)`  |
| "Minore o uguale a" generico    | `x <= y`       | `JSBI.LE(x, y)`  |
| "Maggiore di" generico          | `x > y`        | `JSBI.GT(x, y)`  |
| "Maggiore o uguale a" generico | `x >= y`       | `JSBI.GE(x, y)`  |
| Addizione generica                | `x + y`        | `JSBI.ADD(x, y)` |

I nomi delle variabili `x` e `y` qui indicano che le variabili possono fare riferimento a qualsiasi elemento, ad esempio: `JSBI.GT(101.5, BigInt('100'))` o `str = JSBI.ADD('result: ', BigInt('0x2A'))`.

Purtroppo, alcuni elementi non sono affatto supportati:

| Operazione non supportata | BigInt nativo | JSBI                                 |
| --------------------- | -------------- | ------------------------------------ |
| valori letterali              | `a = 123n;`    | N/A ☹                                |
| increment             | `a++`          | N/A ☹                                |
|                       | `a + 1n`       | `JSBI.add(a, JSBI.BigInt('1'))`      |
| decrement             | `a--`          | N/A ☹                                |
|                       | `a - 1n`       | `JSBI.subtract(a, JSBI.BigInt('1'))` |

Non è possibile replicare il comportamento esatto degli operatori nativi `++` e `--` con funzioni statiche. Poiché JSBI è comunque destinato al transpile, non fornisce un'alternativa simile. È possibile usare `JSBI.add()` e `JSBI.subtract()`.

## <a name="when"></a>Quando?

Ora. La libreria JSBI è già pronta per l'uso.

Quando il supporto nativo per BigInt sarà disponibile ovunque, usare [babel-plugin-transform-jsbi-to-bigint](https://github.com/GoogleChromeLabs/babel-plugin-transform-jsbi-to-bigint) per eseguire il transpile del codice JSBI nel codice BigInt nativo una volta per tutte.

Per ulteriori informazioni sul futuro di JSBI, è possibile consultare il [monitoraggio dei problemi](https://github.com/GoogleChromeLabs/jsbi/issues) e partecipare alla discussione.

Un'ipotesi più vaga riguarda l'uso della libreria JSBI o di una sua estensione come processo di gestione temporanea per altre funzionalità correlate a BigInt. La proposta ufficiale è intenzionalmente minima e lascia spazio ad altre "funzioni libreria" per proposte successive. Gli esempi sono una funzione `exp`+`mod` combinata e funzioni di modifica dei bit.

## <a name="development"></a>Sviluppo

1. Clonare questo repository e `cd` nella directory locale.

1. Usare la versione di Node.js specificata in `.nvmrc`:

     ```sh
     nvm use
     ```

1. Installare le dipendenze per lo sviluppo:

    ```sh
    npm install
    ```

1. Eseguire i test:

    ```sh
    npm test
    ```

    Per l'elenco dei comandi, vedere `npm run`.

## <a name="for-maintainers"></a>Per i gestori

### <a name="how-to-publish-a-new-release"></a>Come pubblicare una nuova versione

1. Nel ramo `main` spostare il numero di versione in `package.json`:

    ```sh
    npm version patch -m 'Release v%s'
    ```

    Anziché `patch`, usare `minor` o `major` [in base alle esigenze](https://semver.org/).

    Si noti che l'operazione genera un commit Git + tag.

1. Eseguire il push del commit e del tag della versione:

    ```sh
    git push
    ```

    Successivamente il CI pubblica automaticamente la nuova versione in npm.
