---
ms.openlocfilehash: f9f95f626a5d55dca7937d56df8b3dd3b7040164
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051387"
---
# <a name="bl-bufferlist"></a>bl *(BufferList)*

[![Stato della compilazione](https://api.travis-ci.com/rvagg/bl.svg?branch=master)](https://travis-ci.com/rvagg/bl/)

**Agente di raccolta, lettore e streamer di elenchi di buffer di Node.js.**

[![NPM](https://nodei.co/npm/bl.svg)](https://nodei.co/npm/bl/)

**bl** è un oggetto di archiviazione per le raccolte di buffer di Node, esponendoli con l'API leggibile del buffer principale. Funziona anche come flusso duplex, in modo da poter raccogliere buffer da un flusso che li genera e generare buffer per un flusso che li usa.

I buffer originali vengono mantenuti inalterati e le copie vengono eseguite solo se necessario. Tutte le letture che richiedono l'uso di un singolo buffer originale restituiranno solo una sezione del buffer, che fa riferimento alla stessa memoria del buffer originale. Le letture che interessano più buffer eseguono la concatenazione in base alle esigenze e restituiscono i risultati in modo trasparente.

```js
const { BufferList } = require('bl')

const bl = new BufferList()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append('hi')                     // bl will also accept & convert Strings
bl.append(Buffer.from('j'))
bl.append(Buffer.from([ 0x3, 0x4 ]))

console.log(bl.length) // 12

console.log(bl.slice(0, 10).toString('ascii')) // 'abcdefghij'
console.log(bl.slice(3, 10).toString('ascii')) // 'defghij'
console.log(bl.slice(3, 6).toString('ascii'))  // 'def'
console.log(bl.slice(3, 8).toString('ascii'))  // 'defgh'
console.log(bl.slice(5, 10).toString('ascii')) // 'fghij'

console.log(bl.indexOf('def')) // 3
console.log(bl.indexOf('asdf')) // -1

// or just use toString!
console.log(bl.toString())               // 'abcdefghij\u0003\u0004'
console.log(bl.toString('ascii', 3, 8))  // 'defgh'
console.log(bl.toString('ascii', 5, 10)) // 'fghij'

// other standard Buffer readables
console.log(bl.readUInt16BE(10)) // 0x0304
console.log(bl.readUInt16LE(10)) // 0x0403
```

Assegnare un callback nel costruttore e usarlo come **[concat-stream](https://github.com/maxogden/node-concat-stream)** :

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

fs.createReadStream('README.md')
  .pipe(BufferListStream((err, data) => { // note 'new' isn't strictly required
    // `data` is a complete Buffer object containing the full data
    console.log(data.toString())
  }))
```

Si noti che quando si usa il metodo *callback* in questo modo, il parametro `data` risultante è una concatenazione di tutti gli oggetti `Buffer` nell'elenco. Per evitare l'overhead di questa concatenazione (nei casi in cui le prestazioni sono estremamente importanti), evitare il metodo *callback* e restare semplicemente in ascolto di `'end'`, come un flusso standard.

In alternativa, per recuperare un URL usare [hyperquest](https://github.com/substack/hyperquest) (dovrebbe funzionare anche con [request](http://github.com/mikeal/request) e con il normale protocollo http di Node):

```js
const hyperquest = require('hyperquest')
const { BufferListStream } = require('bl')

const url = 'https://raw.github.com/rvagg/bl/master/README.md'

hyperquest(url).pipe(BufferListStream((err, data) => {
  console.log(data.toString())
}))
```

In alternativa, è possibile usarlo come flusso leggibile per ricomporre un elenco di buffer in un'origine di output:

```js
const { BufferListStream } = require('bl')
const fs = require('fs')

var bl = new BufferListStream()
bl.append(Buffer.from('abcd'))
bl.append(Buffer.from('efg'))
bl.append(Buffer.from('hi'))
bl.append(Buffer.from('j'))

bl.pipe(fs.createWriteStream('gibberish.txt'))
```

## <a name="api"></a>API

  * <a href="#ctor"><code><b>new BufferList([ buf ])</b></code></a>
  * <a href="#isBufferList"><code><b>BufferList.isBufferList(obj)</b></code></a>
  * <a href="#length"><code>bl.<b>length</b></code></a>
  * <a href="#append"><code>bl.<b>append(buffer)</b></code></a>
  * <a href="#get"><code>bl.<b>get(index)</b></code></a>
  * <a href="#indexOf"><code>bl.<b>indexOf(value[, byteOffset][, encoding])</b></code></a>
  * <a href="#slice"><code>bl.<b>slice([ start[, end ] ])</b></code></a>
  * <a href="#shallowSlice"><code>bl.<b>shallowSlice([ start[, end ] ])</b></code></a>
  * <a href="#copy"><code>bl.<b>copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])</b></code></a>
  * <a href="#duplicate"><code>bl.<b>duplicate()</b></code></a>
  * <a href="#consume"><code>bl.<b>consume(bytes)</b></code></a>
  * <a href="#toString"><code>bl.<b>toString([encoding, [ start, [ end ]]])</b></code></a>
  * <a href="#readXX"><code>bl.<b>readDoubleBE()</b></code>, <code>bl.<b>readDoubleLE()</b></code>, <code>bl.<b>readFloatBE()</b></code>, <code>bl.<b>readFloatLE()</b></code>, <code>bl.<b>readInt32BE()</b></code>, <code>bl.<b>readInt32LE()</b></code>, <code>bl.<b>readUInt32BE()</b></code>, <code>bl.<b>readUInt32LE()</b></code>, <code>bl.<b>readInt16BE()</b></code>, <code>bl.<b>readInt16LE()</b></code>, <code>bl.<b>readUInt16BE()</b></code>, <code>bl.<b>readUInt16LE()</b></code>, <code>bl.<b>readInt8()</b></code>, <code>bl.<b>readUInt8()</b></code></a>
  * <a href="#ctorStream"><code><b>new BufferListStream([ callback ])</b></code></a>

--------------------------------------------------------
<a name="ctor"></a>
### <a name="new-bufferlist-buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferList([ Buffer | Buffer array | BufferList | BufferList array | String ])
Non sono _necessari_ argomenti per il costruttore, ma è possibile inizializzare l'elenco passando un singolo oggetto `Buffer` o una matrice di oggetti `Buffer`.

`new` non è strettamente obbligatorio. Se non si crea un'istanza di un nuovo oggetto, tale operazione verrà eseguita automaticamente. Pertanto, è possibile creare una nuova istanza semplicemente con:

```js
const { BufferList } = require('bl')
const bl = BufferList()

// equivalent to:

const { BufferList } = require('bl')
const bl = new BufferList()
```

--------------------------------------------------------
<a name="isBufferList"></a>
### <a name="bufferlistisbufferlistobj"></a>BufferList.isBufferList(obj)
Determina se l'oggetto passato è un oggetto `BufferList`. Restituisce `true` se l'oggetto passato è un'istanza di `BufferList` **o**`BufferListStream` e `false` in caso contrario.

Nota Non verrà restituito `true` per le istanze di `BufferList` o `BufferListStream` create dalle versioni di questa libreria prima dell'aggiunta di questo metodo statico.

--------------------------------------------------------
<a name="length"></a>
### <a name="bllength"></a>bl.length
Ottenere la lunghezza dell'elenco in byte. Si tratta della somma delle lunghezze di tutti i buffer contenuti nell'elenco, meno l'eventuale offset iniziale per un buffer semi-utilizzato all'inizio. Deve rappresentare in modo accurato il numero totale di byte che possono essere letti dall'elenco.

--------------------------------------------------------
<a name="append"></a>
### <a name="blappendbuffer--buffer-array--bufferlist--bufferlist-array--string"></a>bl.append(Buffer | Buffer array | BufferList | BufferList array | String)
`append(buffer)` aggiunge un buffer o BufferList aggiuntivo all'elenco interno. `this` viene restituito in modo da poter essere concatenato.

--------------------------------------------------------
<a name="get"></a>
### <a name="blgetindex"></a>bl.get(index)
`get()` restituirà il byte in corrispondenza dell'indice specificato.

--------------------------------------------------------
<a name="indexOf"></a>
### <a name="blindexofvalue-byteoffset-encoding"></a>bl.indexOf(value[, byteOffset][, encoding])
`get()` restituirà il byte in corrispondenza dell'indice specificato.
Il metodo `indexOf()` restituisce il primo indice in corrispondenza del quale un determinato elemento può essere trovato in BufferList oppure -1 se non è presente.

--------------------------------------------------------
<a name="slice"></a>
### <a name="blslice-start--end--"></a>bl.slice([ start, [ end ] ])
`slice()` restituisce un nuovo oggetto `Buffer` contenente i byte all'interno dell'intervallo specificato. Sia `start` che `end` sono facoltativi e hanno come valore predefinito rispettivamente l'inizio e la fine dell'elenco.

Se l'intervallo richiesto interessa un singolo buffer interno, verrà restituita una sezione del buffer che condivide l'intervallo di memoria originale di tale buffer. Se l'intervallo interessa più buffer, è probabile che si verifichino operazioni di copia per fornire un buffer uniforme.

--------------------------------------------------------
<a name="shallowSlice"></a>
### <a name="blshallowslice-start--end--"></a>bl.shallowSlice([ start, [ end ] ])
`shallowSlice()` restituisce un nuovo oggetto `BufferList` contenente i byte all'interno dell'intervallo specificato. Sia `start` che `end` sono facoltativi e hanno come valore predefinito rispettivamente l'inizio e la fine dell'elenco.

Non verranno eseguite copie. Tutti i buffer nel risultato condividono la memoria con l'elenco originale.

--------------------------------------------------------
<a name="copy"></a>
### <a name="blcopydest--deststart--srcstart--srcend---"></a>bl.copy(dest, [ destStart, [ srcStart [, srcEnd ] ] ])
`copy()` copia il contenuto dell'elenco nel buffer `dest`, a partire da `destStart` e con i byte all'interno dell'intervallo specificato tramite `srcStart` e `srcEnd`. `destStart`, `start` e `end` sono facoltativi e hanno come valore predefinito l'inizio del buffer `dest` e l'inizio e la fine dell'elenco, rispettivamente.

--------------------------------------------------------
<a name="duplicate"></a>
### <a name="blduplicate"></a>bl.duplicate()
`duplicate()` esegue una **copia superficiale** dell'elenco. I buffer interni rimangono invariati, quindi se si modificano i buffer sottostanti, la modifica verrà riflessa sia nell'originale che nel duplicato. Questo metodo è necessario se si vuole chiamare `consume()` o `pipe()` e mantenere comunque l'elenco originale. Esempio:

```js
var bl = new BufferListStream()

bl.append('hello')
bl.append(' world')
bl.append('\n')

bl.duplicate().pipe(process.stdout, { end: false })

console.log(bl.toString())
```

--------------------------------------------------------
<a name="consume"></a>
### <a name="blconsumebytes"></a>bl.consume(bytes)
`consume()` sposterà i byte *all'inizio dell'elenco*. Il numero di byte usati non deve essere allineato alle dimensioni dei buffer interni: gli offset iniziali verranno calcolati di conseguenza per offrire una visualizzazione coerente dei dati.

--------------------------------------------------------
<a name="toString"></a>
### <a name="bltostringencoding--start--end-"></a>bl.toString([encoding, [ start, [ end ]]])
`toString()` restituirà una rappresentazione in forma di stringa del buffer. Gli argomenti facoltativi `start` e `end` vengono passati a `slice()`, mentre `encoding` viene passato a `toString()` del buffer risultante. Per maggiori informazioni, vedere la documentazione di [Buffer#toString()](http://nodejs.org/docs/latest/api/buffer.html#buffer_buf_tostring_encoding_start_end).

--------------------------------------------------------
<a name="readXX"></a>
### <a name="blreaddoublebe-blreaddoublele-blreadfloatbe-blreadfloatle-blreadint32be-blreadint32le-blreaduint32be-blreaduint32le-blreadint16be-blreadint16le-blreaduint16be-blreaduint16le-blreadint8-blreaduint8"></a>bl.readDoubleBE(), bl.readDoubleLE(), bl.readFloatBE(), bl.readFloatLE(), bl.readInt32BE(), bl.readInt32LE(), bl.readUInt32BE(), bl.readUInt32LE(), bl.readInt16BE(), bl.readInt16LE(), bl.readUInt16BE(), bl.readUInt16LE(), bl.readInt8(), bl.readUInt8()

Tutti i metodi standard di lettura dei byte dell'interfaccia `Buffer` sono implementati e funzioneranno in modo trasparente tra i limiti interni dei buffer.

Per informazioni sul funzionamento di questi elementi, vedere la documentazione di <b><code>[Buffer](http://nodejs.org/docs/latest/api/buffer.html)</code></b>.

--------------------------------------------------------
<a name="ctorStream"></a>
### <a name="new-bufferliststream-callback--buffer--buffer-array--bufferlist--bufferlist-array--string-"></a>new BufferListStream([ callback | Buffer | Buffer array | BufferList | BufferList array | String ])
**BufferListStream** è un **[flusso duplex](http://nodejs.org/docs/latest/api/stream.html#stream_class_stream_duplex)** di Node, quindi può essere letto e scritto in come un flusso Node standard. È anche possibile eseguire `pipe()` a e da un'istanza **BufferListStream**.

Il costruttore accetta un callback facoltativo. Se specificato, il callback verrà chiamato con un argomento di errore seguito da un riferimento all'istanza **bl**, quando viene chiamato `bl.end()` (ad esempio da un flusso inviato tramite pipe). Si tratta di un metodo pratico per raccogliere l'intero contenuto di un flusso, in particolare quando il flusso è *voluminoso*, ad esempio un flusso di rete.

Normalmente non sono necessari argomenti per il costruttore, ma è possibile inizializzare l'elenco passando un singolo oggetto `Buffer` o una matrice di oggetti `Buffer`.

`new` non è strettamente obbligatorio. Se non si crea un'istanza di un nuovo oggetto, tale operazione verrà eseguita automaticamente. Pertanto, è possibile creare una nuova istanza semplicemente con:

```js
const { BufferListStream } = require('bl')
const bl = BufferListStream()

// equivalent to:

const { BufferListStream } = require('bl')
const bl = new BufferListStream()
```

Nota Per motivi di compatibilità con le versioni precedenti, `BufferListStream` è l'esportazione **predefinita** quando si esegue `require('bl')`:

```js
const { BufferListStream } = require('bl')
// equivalent to:
const BufferListStream = require('bl')
```

--------------------------------------------------------

## <a name="contributors"></a>Autori di contributi

**bl** è stato reso disponibile da:

 * [Rod Vagg](https://github.com/rvagg)
 * [Matteo Collina](https://github.com/mcollina)
 * [Jarett Cruger](https://github.com/jcrugzz)

<a name="license"></a>
## <a name="license-amp-copyright"></a>Licenza e copyright

Copyright (c) 2013-2019 collaboratori di bl (elencati in precedenza).

bl è concesso in licenza secondo i termini della licenza MIT. Tutti i diritti non concessi in modo esplicito nella licenza MIT sono riservati. Per altri dettagli, vedere il file LICENSE.md incluso.
