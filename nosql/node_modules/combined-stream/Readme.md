---
ms.openlocfilehash: 0e4384a6edea7b3a580ffa5b32236b7f8b251834
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051380"
---
# <a name="combined-stream"></a>combined-stream

Flusso che genera più flussi uno dopo l'altro.

**Nota** Attualmente `combined-stream` funziona solo con i flussi della versione 1. È in corso il passaggio di questa libreria ai flussi della versione 2. Qualsiasi aiuto è molto apprezzato. :) Nel frattempo è possibile esplorare altre librerie che forniscono il supporto di streams2 con un certo livello di compatibilità con `combined-stream`.

- [combined-stream2](https://www.npmjs.com/package/combined-stream2): Un sostituto compatibile con streams2 per il modulo combined-stream.

- [multistream](https://www.npmjs.com/package/multistream): Flusso che genera più flussi uno dopo l'altro.

## <a name="installation"></a>Installazione

``` bash
npm install combined-stream
```

## <a name="usage"></a>Utilizzo

Di seguito è riportato un semplice esempio che illustra come usare combined-stream per combinare due file in uno:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Anche se l'esempio precedente funziona correttamente, sospende tutti i flussi di origine fino a quando non sono necessari. Se non si vuole che ciò accada, è possibile impostare `pauseStreams` su `false`:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create({pauseStreams: false});
combinedStream.append(fs.createReadStream('file1.txt'));
combinedStream.append(fs.createReadStream('file2.txt'));

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

Tuttavia, com'è possibile procedere se non si dispone ancora di tutti i flussi di origine o non si vogliono allocare immediatamente le risorse (descrittori di file, memoria e così via) per tali flussi?
In tal caso, è sufficiente specificare un callback che fornisca il flusso chiamando una funzione `next()`:

``` javascript
var CombinedStream = require('combined-stream');
var fs = require('fs');

var combinedStream = CombinedStream.create();
combinedStream.append(function(next) {
  next(fs.createReadStream('file1.txt'));
});
combinedStream.append(function(next) {
  next(fs.createReadStream('file2.txt'));
});

combinedStream.pipe(fs.createWriteStream('combined.txt'));
```

## <a name="api"></a>API

### <a name="combinedstreamcreateoptions"></a>CombinedStream.create([options])

Restituisce un nuovo oggetto combined-stream. Le opzioni disponibili sono:

* `maxDataSize`
* `pauseStreams`

L'effetto di queste opzioni è descritto di seguito.

### <a name="combinedstreampausestreams--true"></a>combinedStream.pauseStreams = `true`

Indica se applicare la contropressione ai flussi sottostanti. Se impostato su `false`, i flussi sottostanti non verranno mai sospesi. Se impostato su `true`, i flussi sottostanti verranno sospesi subito dopo l'accodamento, nonché quando `delayedStream.pipe()` richiede di applicare la limitazione.

### <a name="combinedstreammaxdatasize--2--1024--1024"></a>combinedStream.maxDataSize = `2 * 1024 * 1024`

Quantità massima di byte (o caratteri) da memorizzare nel buffer per tutti i flussi di origine.
Se questo valore viene superato, `combinedStream` genera un evento `'error'`.

### <a name="combinedstreamdatasize--0"></a>combinedStream.dataSize = `0`

Quantità di byte (o caratteri) attualmente memorizzati nel buffer da `combinedStream`.

### <a name="combinedstreamappendstream"></a>combinedStream.append(stream)

Accoda l'oggetto `stream` specificato all'oggetto combinedStream. Se `pauseStreams` è impostato su true, questo flusso verrà sospeso immediatamente.

`streams` può anche essere una funzione che accetta un parametro denominato `next`. `next` è una funzione che deve essere richiamata per fornire il flusso `next`. Vedere l'esempio precedente.

Indipendentemente dal modo in cui viene accodato `stream`, combined-stream collega sempre un listener `'error'`, quindi non è necessario eseguire questa operazione manualmente.

Caso speciale: `stream` può anche essere una stringa o un buffer.

### <a name="combinedstreamwritedata"></a>combinedStream.write(data)

Non è necessario chiamarlo: `combinedStream` si occupa automaticamente del piping dei flussi accodati.

### <a name="combinedstreamresume"></a>combinedStream.resume()

Causa l'avvio dello svuotamento dei flussi gestiti da parte di `combinedStream`. La funzione è idempotente e genera ogni volta anche un evento `'resume'`, che in genere viene inviato al flusso in fase di svuotamento.

### <a name="combinedstreampause"></a>combinedStream.pause();

Se `combinedStream.pauseStreams` è impostato su `false`, non esegue alcuna operazione.
In caso contrario, viene generato un evento `'pause'`, che viene inviato al flusso attualmente in fase di svuotamento, in modo da poterlo usare per applicare la contropressione.

### <a name="combinedstreamend"></a>combinedStream.end();

Imposta `combinedStream.writable` su false, genera un evento `'end'` e rimuove tutti i flussi dalla coda.

### <a name="combinedstreamdestroy"></a>combinedStream.destroy();

Uguale a `combinedStream.end()`, tranne che genera un evento `'close'` anziché `'end'`.

## <a name="license"></a>Licenza

combined-stream è concesso in licenza secondo i termini della licenza MIT.
