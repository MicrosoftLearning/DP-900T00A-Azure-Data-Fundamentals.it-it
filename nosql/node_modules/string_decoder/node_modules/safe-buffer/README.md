---
ms.openlocfilehash: 75916065970faa645bca603327ecbaea09afe12e
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051179"
---
# <a name="safe-buffer-travistravis-imagetravis-url-npmnpm-imagenpm-url-downloadsdownloads-imagedownloads-url-javascript-style-guidestandard-imagestandard-url"></a>safe-buffer [![travis][travis-image]][travis-url] [![npm][npm-image]][npm-url] [![download][downloads-image]][downloads-url] [![guida di stile javascript][standard-image]][standard-url]

[travis-image]: https://img.shields.io/travis/feross/safe-buffer/master.svg
[travis-url]: https://travis-ci.org/feross/safe-buffer
[npm-image]: https://img.shields.io/npm/v/safe-buffer.svg
[npm-url]: https://npmjs.org/package/safe-buffer
[downloads-image]: https://img.shields.io/npm/dm/safe-buffer.svg
[downloads-url]: https://npmjs.org/package/safe-buffer
[standard-image]: https://img.shields.io/badge/code_style-standard-brightgreen.svg
[standard-url]: https://standardjs.com

#### <a name="safer-nodejs-buffer-api"></a>API Buffer di Node.js più sicura

**Usare le nuove API Buffer di Node.js (`Buffer.from`, `Buffer.alloc`, `Buffer.allocUnsafe`, `Buffer.allocUnsafeSlow`) in tutte le versioni di Node.js.**

**Usare l'implementazione predefinita, se disponibile.**

## <a name="install"></a>Installazione

```
npm install safe-buffer
```

## <a name="usage"></a>utilizzo

L'obiettivo di questo pacchetto è fornire una sostituzione sicura per `Buffer` di node.js.

Si tratta di una sostituzione drop-in per `Buffer`. È possibile usarla aggiungendo una riga `require` all'inizio dei moduli node.js:

```js
var Buffer = require('safe-buffer').Buffer

// Existing buffer code will continue to work without issues:

new Buffer('hey', 'utf8')
new Buffer([1, 2, 3], 'utf8')
new Buffer(obj)
new Buffer(16) // create an uninitialized buffer (potentially unsafe)

// But you can use these new explicit APIs to make clear what you want:

Buffer.from('hey', 'utf8') // convert from many types to a Buffer
Buffer.alloc(16) // create a zero-filled buffer (safe)
Buffer.allocUnsafe(16) // create an uninitialized buffer (potentially unsafe)
```

## <a name="api"></a>api

### <a name="class-method-bufferfromarray"></a>Metodo di classe: Buffer.from(array)
<!-- YAML
added: v3.0.0
-->

* `array` {Array}

Alloca un nuovo `Buffer` usando un `array` di ottetti.

```js
const buf = Buffer.from([0x62,0x75,0x66,0x66,0x65,0x72]);
  // creates a new Buffer containing ASCII bytes
  // ['b','u','f','f','e','r']
```

Verrà generato un `TypeError` se `array` non è un `Array`.

### <a name="class-method-bufferfromarraybuffer-byteoffset-length"></a>Metodo di classe: Buffer.from(arrayBuffer[, byteOffset[, length]])
<!-- YAML
added: v5.10.0
-->

* `arrayBuffer` {ArrayBuffer} Proprietà `.buffer` di `TypedArray` o `new ArrayBuffer()`
* `byteOffset` {Number} Valore predefinito: `0`
* `length` {Number} Valore predefinito: `arrayBuffer.length - byteOffset`

Quando viene passato un riferimento alla proprietà `.buffer` di un'istanza di `TypedArray`, il nuovo `Buffer` creato condividerà la stessa memoria allocata di TypedArray.

```js
const arr = new Uint16Array(2);
arr[0] = 5000;
arr[1] = 4000;

const buf = Buffer.from(arr.buffer); // shares the memory with arr;

console.log(buf);
  // Prints: <Buffer 88 13 a0 0f>

// changing the TypedArray changes the Buffer also
arr[1] = 6000;

console.log(buf);
  // Prints: <Buffer 88 13 70 17>
```

Gli argomenti facoltativi `byteOffset` e `length` specificano un intervallo di memoria all'interno di `arrayBuffer` che verrà condiviso da `Buffer`.

```js
const ab = new ArrayBuffer(10);
const buf = Buffer.from(ab, 0, 2);
console.log(buf.length);
  // Prints: 2
```

Verrà generato un `TypeError` se `arrayBuffer` non è un `ArrayBuffer`.

### <a name="class-method-bufferfrombuffer"></a>Metodo di classe: Buffer.from(buffer)
<!-- YAML
added: v3.0.0
-->

* `buffer` {Buffer}

Copia i dati `buffer` passati in una nuova istanza di `Buffer`.

```js
const buf1 = Buffer.from('buffer');
const buf2 = Buffer.from(buf1);

buf1[0] = 0x61;
console.log(buf1.toString());
  // 'auffer'
console.log(buf2.toString());
  // 'buffer' (copy is not changed)
```

Verrà generato un `TypeError` se `buffer` non è un `Buffer`.

### <a name="class-method-bufferfromstr-encoding"></a>Metodo di classe: Buffer.from(str[, encoding])
<!-- YAML
added: v5.10.0
-->

* `str` {String} Stringa da codificare.
* `encoding` {String} Codifica da usare, valore predefinito: `'utf8'`

Crea un nuovo `Buffer` contenente la stringa JavaScript specificata `str`. Se specificato, il parametro `encoding` identifica la codifica dei caratteri.
Se non specificato, il valore predefinito di `encoding` è `'utf8'`.

```js
const buf1 = Buffer.from('this is a tést');
console.log(buf1.toString());
  // prints: this is a tést
console.log(buf1.toString('ascii'));
  // prints: this is a tC)st

const buf2 = Buffer.from('7468697320697320612074c3a97374', 'hex');
console.log(buf2.toString());
  // prints: this is a tést
```

Verrà generato un `TypeError` se `str` non è una stringa.

### <a name="class-method-bufferallocsize-fill-encoding"></a>Metodo di classe: Buffer.alloc(size[, fill[, encoding]])
<!-- YAML
added: v5.10.0
-->

* `size` {Number}
* `fill` {Value} Valore predefinito: `undefined`
* `encoding` {String} Valore predefinito: `utf8`

Alloca un nuovo `Buffer` di `size` byte. Se `fill` è `undefined`, `Buffer` sarà *riempito di zeri*.

```js
const buf = Buffer.alloc(5);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

`size` deve essere minore o uguale al valore di `require('buffer').kMaxLength` (nelle architetture a 64 bit, `kMaxLength` è `(2^31)-1`). In caso contrario viene generato un [`RangeError`][]. Verrà creato un buffer di lunghezza zero se viene specificato un valore minore o uguale a 0 per `size`.

Se si specifica `fill`, il `Buffer` allocato verrà inizializzato chiamando `buf.fill(fill)`. Vedere [`buf.fill()`][] pere altre informazioni.

```js
const buf = Buffer.alloc(5, 'a');
console.log(buf);
  // <Buffer 61 61 61 61 61>
```

Se si specificano sia `fill` che `encoding`, il `Buffer` allocato verrà inizializzato chiamando `buf.fill(fill, encoding)`. Esempio:

```js
const buf = Buffer.alloc(11, 'aGVsbG8gd29ybGQ=', 'base64');
console.log(buf);
  // <Buffer 68 65 6c 6c 6f 20 77 6f 72 6c 64>
```

La chiamata di `Buffer.alloc(size)` può essere notevolmente più lenta rispetto all'alternativa `Buffer.allocUnsafe(size)`, ma garantisce che il contenuto dell'istanza di `Buffer` appena creata non *contenga mai dati sensibili*.

Verrà generato un `TypeError` se `size` non è un numero.

### <a name="class-method-bufferallocunsafesize"></a>Metodo di classe: Buffer.allocUnsafe(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Alloca un nuovo `Buffer` *non riempito di zeri* di `size` byte.  `size` deve essere minore o uguale al valore di `require('buffer').kMaxLength` (nelle architetture a 64 bit, `kMaxLength` è `(2^31)-1`). In caso contrario viene generato un [`RangeError`][]. Verrà creato un buffer di lunghezza zero se viene specificato un valore minore o uguale a 0 per `size`.

La memoria sottostante per le istanze di `Buffer` create in questo modo *non viene inizializzata*. Il contenuto del nuovo `Buffer` creato è sconosciuto e *potrebbe contenere dati sensibili*. Usare [`buf.fill(0)`][] per inizializzare tali istanze di `Buffer` su zero.

```js
const buf = Buffer.allocUnsafe(5);
console.log(buf);
  // <Buffer 78 e0 82 02 01>
  // (octets will be different, every time)
buf.fill(0);
console.log(buf);
  // <Buffer 00 00 00 00 00>
```

Verrà generato un `TypeError` se `size` non è un numero.

Si noti che il modulo `Buffer` prealloca un'istanza di `Buffer` interna con dimensioni `Buffer.poolSize`, che viene usata come pool per l'allocazione rapida di nuove istanze di `Buffer` create usando `Buffer.allocUnsafe(size)` (e il costruttore deprecato `new Buffer(size)`) solo quando `size` è minore o uguale a `Buffer.poolSize >> 1` (piano intero di `Buffer.poolSize` diviso per due). Il valore predefinito di `Buffer.poolSize` è `8192` ma può essere modificato.

L'uso di questo pool di memoria interna preallocata è una differenza fondamentale tra la chiamata di `Buffer.alloc(size, fill)` e `Buffer.allocUnsafe(size).fill(fill)`. Nello specifico, `Buffer.alloc(size, fill)` non userà *mai* il pool di Buffer interno, mentre `Buffer.allocUnsafe(size).fill(fill)` *userà* il pool di Buffer interno se `size` è minore o uguale alla metà di `Buffer.poolSize`. La differenza è sottile, ma può essere importante quando un'applicazione richiede le prestazioni aggiuntive fornite da `Buffer.allocUnsafe(size)`.

### <a name="class-method-bufferallocunsafeslowsize"></a>Metodo di classe: Buffer.allocUnsafeSlow(size)
<!-- YAML
added: v5.10.0
-->

* `size` {Number}

Alloca un nuovo `Buffer` *non riempito di zeri* e non in pool di `size` byte.  `size` deve essere minore o uguale al valore di `require('buffer').kMaxLength` (nelle architetture a 64 bit, `kMaxLength` è `(2^31)-1`). In caso contrario viene generato un [`RangeError`][]. Verrà creato un buffer di lunghezza zero se viene specificato un valore minore o uguale a 0 per `size`.

La memoria sottostante per le istanze di `Buffer` create in questo modo *non viene inizializzata*. Il contenuto del nuovo `Buffer` creato è sconosciuto e *potrebbe contenere dati sensibili*. Usare [`buf.fill(0)`][] per inizializzare tali istanze di `Buffer` su zero.

Quando si usa `Buffer.allocUnsafe()` per allocare nuove istanze di `Buffer`, le allocazioni sotto i 4 KB vengono per impostazione predefinita sezionate da un singolo `Buffer` preallocato. Ciò consente alle applicazioni di evitare il sovraccarico di Garbage Collection per la creazione di molti buffer allocati singolarmente. Questo approccio migliora sia le prestazioni che l'utilizzo della memoria eliminando la necessità di tracciamento e pulizia per così tanti oggetti `Persistent`.

Tuttavia, nel caso in cui uno sviluppatore debba conservare un piccolo blocco di memoria da un pool per un periodo di tempo indeterminato, potrebbe essere opportuno creare un'istanza di Buffer non in pool usando `Buffer.allocUnsafeSlow()`, quindi copiare i bit pertinenti.

```js
// need to keep around a few small chunks of memory
const store = [];

socket.on('readable', () => {
  const data = socket.read();
  // allocate for retained data
  const sb = Buffer.allocUnsafeSlow(10);
  // copy the data into the new allocation
  data.copy(sb, 0, 0, 10);
  store.push(sb);
});
```

L'uso di `Buffer.allocUnsafeSlow()` deve essere considerato come ultima risorsa *dopo* che uno sviluppatore ha notato una conservazione della memoria ingiustificata nelle applicazioni.

Verrà generato un `TypeError` se `size` non è un numero.

### <a name="all-the-rest"></a>Tutto il resto

Il resto dell'API `Buffer` è esattamente uguale a quello in node.js.
[Vedere la documentazione](https://nodejs.org/api/buffer.html).


## <a name="related-links"></a>Collegamenti correlati

- [Problema di Node.js: Buffer(number) non è sicuro](https://github.com/nodejs/node/issues/4660)
- [Proposta di miglioramento di Node.js: Buffer.from/Buffer.alloc/Buffer.zalloc/Buffer() deprecati nella documentazione](https://github.com/nodejs/node-eps/pull/4)

## <a name="why-is-buffer-unsafe"></a>Perché `Buffer` non è sicuro?

Attualmente, il costruttore node.js `Buffer` è sottoposto a overload per gestire molti tipi di argomenti diversi, ad esempio `String`, `Array`, `Object`, `TypedArrayView`(`Uint8Array` e così via), `ArrayBuffer` e anche `Number`.

L'API è ottimizzata per la praticità: è possibile specificare qualsiasi tipo e proverà a eseguire le operazioni richieste.

Poiché il costruttore Buffer è così potente, spesso si trova codice simile al seguente:

```js
// Convert UTF-8 strings to hex
function toHex (str) {
  return new Buffer(str).toString('hex')
}
```

***Ma cosa succede se `toHex` viene chiamato con un argomento `Number`?***

### <a name="remote-memory-disclosure"></a>Esposizione di memoria remota

Se un utente malintenzionato riesce a fare in modo che il programma chiami il costruttore `Buffer` con un argomento `Number`, può allocare memoria non inizializzata dal processo di node.js.
Ciò potrebbe causare potenzialmente la divulgazione di chiavi private TLS, dati utente o password di database.

Quando al costruttore `Buffer` viene passato un argomento `Number`, restituisce un blocco di memoria **UNINITIALIZED** del `size` specificato. Quando si crea un `Buffer` in questo modo, è **NECESSARIO** sovrascrivere il contenuto prima di restituirlo all'utente.

Dalla [documentazione di node.js](https://nodejs.org/api/buffer.html#buffer_new_buffer_size):

> `new Buffer(size)`
>
> - `size` Number
>
> La memoria sottostante per le istanze di `Buffer` create in questo modo non viene inizializzata.
> **Il contenuto del nuovo `Buffer` creato è sconosciuto e potrebbe contenere dati sensibili.** Usare `buf.fill(0)` per inizializzare un Buffer su zero.

(Enfasi nostra.)

Ogni volta che il programmatore intende creare un `Buffer` non inizializzato, si vedrà spesso codice simile al seguente:

```js
var buf = new Buffer(16)

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="would-this-ever-be-a-problem-in-real-code"></a>Ma questo potrebbe essere effettivamente un problema nel codice reale?

Sì. È sorprendentemente comune dimenticare di controllare il tipo delle variabili in un linguaggio tipizzato in modo dinamico come JavaScript.

In genere, le conseguenze del presumere un tipo errato sono l'arresto anomalo del programma con un'eccezione non intercettata. Ma la modalità di errore quando si dimentica di controllare il tipo degli argomenti per il costruttore `Buffer` è decisamente più grave.

Ecco un esempio di servizio vulnerabile che accetta un payload JSON e lo converte in esadecimale:

```js
// Take a JSON payload {str: "some string"} and convert it to hex
var server = http.createServer(function (req, res) {
  var data = ''
  req.setEncoding('utf8')
  req.on('data', function (chunk) {
    data += chunk
  })
  req.on('end', function () {
    var body = JSON.parse(data)
    res.end(new Buffer(body.str).toString('hex'))
  })
})

server.listen(8080)
```

In questo esempio, un client HTTP deve solo inviare:

```json
{
  "str": 1000
}
```

per ottenere 1.000 byte di memoria non inizializzata dal server.

Questo è un bug molto grave. La gravità è simile a quella del [bug Heartbleed](http://heartbleed.com/) che ha consentito a utenti malintenzionati remoti di esporre la memoria di processi OpenSSL.


### <a name="which-real-world-packages-were-vulnerable"></a>Quali pacchetti reali erano vulnerabili?

#### [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht)

[Mathias Buus](https://github.com/mafintosh) e io ([Feross Aboukhadijeh](http://feross.org/)) abbiamo trovato questo problema in uno dei nostri pacchetti, [`bittorrent-dht`](https://www.npmjs.com/package/bittorrent-dht). Il bug consentirebbe a chiunque su Internet di inviare una serie di messaggi a un utente di `bittorrent-dht` e di ottenere la divulgazione di 20 byte alla volta di memoria non inizializzata dal processo di node.js.

Ecco [il commit](https://github.com/feross/bittorrent-dht/commit/6c7da04025d5633699800a99ec3fbadf70ad35b8) di risoluzione. È stata rilasciata una nuova versione corretta, è stata creato un [avviso di divulgazione per il progetto di sicurezza di Node](https://nodesecurity.io/advisories/68) e sono state deprecate tutte le versioni vulnerabili in npm, in modo che gli utenti ricevano un avviso per l'aggiornamento a una versione più recente.

#### [`ws`](https://www.npmjs.com/package/ws)

Questo problema ci ha portato a chiederci se ci fossero altri pacchetti vulnerabili. Come era prevedibile, entro un breve periodo di tempo abbiamo rilevato lo stesso problema in [`ws`](https://www.npmjs.com/package/ws), l'implementazione WebSocket più diffusa in node.js.

Se alcune API venivano chiamate con parametri `Number` anziché `String` o `Buffer` come previsto, la memoria del server non inizializzata sarebbe stata divulgata al peer remoto.

Questi erano i metodi vulnerabili:

```js
socket.send(number)
socket.ping(number)
socket.pong(number)
```

Ecco un server socket vulnerabile con alcune funzionalità echo:

```js
server.on('connection', function (socket) {
  socket.on('message', function (message) {
    message = JSON.parse(message)
    if (message.type === 'echo') {
      socket.send(message.data) // send back the user's message
    }
  })
})
```

La chiamata di `socket.send(number)` nel server divulgherà la memoria del server.

Ecco [la release](https://github.com/websockets/ws/releases/tag/1.0.1) in cui è stato risolto il problema, con una spiegazione più dettagliata. Ringraziamenti a [Annaut Kazemier](https://github.com/3rd-Eden) per la correzione rapida. Ecco l'[avviso di divulgazione per il progetto di sicurezza di Node](https://nodesecurity.io/advisories/67).


### <a name="whats-the-solution"></a>Qual è la soluzione?

È importante che node.js offra un modo rapido per ottenere memoria, altrimenti le applicazioni per cui le prestazioni sono cruciali risulterebbero inutilmente più lente.

Ma serve un modo migliore per *segnalare il nostro intento* come programmatori. **Quando serve memoria non inizializzata, è necessario richiederla in modo esplicito.**

Non è consigliabile inserire funzionalità sensibili in un'API intuitiva per gli sviluppatori, che accetta liberamente molti tipi diversi. Questo tipo di API incoraggia la pigrizia, come il passaggio di variabili senza un controllo attento del tipo.

#### <a name="a-new-api-bufferallocunsafenumber"></a>Una nuova API: `Buffer.allocUnsafe(number)`

La funzionalità per la creazione di buffer con memoria non inizializzata deve far parte di un'altra API. Proponiamo `Buffer.allocUnsafe(number)`. In questo modo, non fa parte di un'API che spesso riceve come input dell'utente il passaggio di tutti i tipi diversi.

```js
var buf = Buffer.allocUnsafe(16) // careful, uninitialized memory!

// Immediately overwrite the uninitialized buffer with data from another buffer
for (var i = 0; i < buf.length; i++) {
  buf[i] = otherBuf[i]
}
```


### <a name="how-do-we-fix-nodejs-core"></a>Come è stato corretto node.js core?

Abbiamo inviato [una richiesta pull a node.js core](https://github.com/nodejs/node/pull/4514) (di cui è stato eseguito il merge come `semver-major`) che difende da un caso:

```js
var str = 16
new Buffer(str, 'utf8')
```

In questa situazione, è implicito che il programmatore intendesse che il primo argomento fosse una stringa, avendo passato una codifica come secondo argomento. Attualmente, node.js allocherà memoria non inizializzata nel caso di `new Buffer(number, encoding)`, che probabilmente non corrisponde alle intenzioni del programmatore.

Ma questa è solo una soluzione parziale, dal momento che se il programmatore esegue `new Buffer(variable)` (senza un parametro `encoding`) non c'è modo di sapere quali fossero le intenzioni. Se capita che `variable` sia un numero, a volte verrà restituita memoria non inizializzata.

### <a name="whats-the-real-long-term-fix"></a>Qual è la vera correzione a lungo termine?

Potremmo deprecare e rimuovere `new Buffer(number)` e usare `Buffer.allocUnsafe(number)` quando è necessaria memoria non inizializzata. Ma questo significherebbe compromettere il funzionamento di migliaia di pacchetti.

~~Crediamo che la soluzione migliore sia:~~

~~1. Modificare `new Buffer(number)` in modo che restituisca memoria sicura e azzerata~~

~~2. Creare una nuova API per la creazione di Buffer non inizializzati. Proponiamo: `Buffer.allocUnsafe(number)`~~

#### <a name="update"></a>Aggiornamento

È ora supportata l'aggiunta di tre nuove API:

- `Buffer.from(value)` - convertire da qualsiasi tipo a un buffer
- `Buffer.alloc(size)` - creare un buffer riempito di zeri
- `Buffer.allocUnsafe(size)` - creare un buffer non inizializzato con le dimensioni specificate

Questo risolve il problema principale che ha interessato `ws` e `bittorrent-dht`, ovvero `Buffer(variable)` indotto ingannevolmente ad accettare un argomento numerico.

In questo modo, il codice esistente continua a funzionare e l'impatto sull'ecosistema npm sarà minimo. Nel corso del tempo, i responsabili della manutenzione di npm potranno eseguire la migrazione del codice critico per le prestazioni per l'uso di `Buffer.allocUnsafe(number)` invece di `new Buffer(number)`.


### <a name="conclusion"></a>Conclusioni

Riteniamo che esista un problema di progettazione grave che riguarda l'API `Buffer` nella sua forma attuale. Promuove software non sicuro inserendo funzionalità ad alto rischio in un'API comoda con "caratteristiche ergonomiche per gli sviluppatori".

Non si è trattato di un esercizio puramente teorico perché il problema è stato riscontrato in alcuni dei pacchetti npm più diffusi.

Fortunatamente, c'è una correzione semplice che può essere applicata subito. Usare `safe-buffer` al posto di `buffer`.

```js
var Buffer = require('safe-buffer').Buffer
```

Speriamo che alla fine node.js core possa passare a questo nuovo comportamento più sicuro. Riteniamo che l'impatto sull'ecosistema sarebbe minimo perché non è una modifica che causa un'interruzione.
I pacchetti popolari e ben gestiti potrebbero essere aggiornati velocemente per l'uso di `Buffer.alloc`, mentre i pacchetti meno recenti e non sicuri risulterebbero magicamente protetti da questo vettore di attacco.


## <a name="links"></a>collegamenti

- [Richiesta pull Node.js: buffer: generare un'eccezione se vengono passate sia la lunghezza che la codifica](https://github.com/nodejs/node/pull/4514)
- [Avviso di divulgazione per il progetto di sicurezza di Node per `ws`](https://nodesecurity.io/advisories/67)
- [Avviso di divulgazione per il progetto di sicurezza di Node per `bittorrent-dht`](https://nodesecurity.io/advisories/68)


## <a name="credit"></a>ringraziamenti

I problemi originali in `bittorrent-dht` ([divulgazione](https://nodesecurity.io/advisories/68)) e `ws` ([divulgazione](https://nodesecurity.io/advisories/67)) sono state scoperti da [Mathias Buus](https://github.com/mafintosh) e [Feross Aboukhadijeh](http://feross.org/).

Grazie ad [Adam Baldwin](https://github.com/evilpacket) per aver contribuito a divulgare questi problemi e per il suo contributo a capo del [progetto di sicurezza di Node](https://nodesecurity.io/).

Grazie a [John Hiesey](https://github.com/jhiesey) per la revisione di questo file README e il controllo del codice.


## <a name="license"></a>license

MIT. Copyright (C) [Feross Aboukhadijeh](http://feross.org)
