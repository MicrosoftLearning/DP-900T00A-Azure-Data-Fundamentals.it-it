---
ms.openlocfilehash: 841a4ef811cc186a2302309fbbc4a380d1ba5cbd
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050946"
---
# <a name="tar-fs"></a>tar-fs

Binding di filesystem per [tar-stream](https://github.com/mafintosh/tar-stream).

```
npm install tar-fs
```

[![stato della compilazione](https://secure.travis-ci.org/mafintosh/tar-fs.png)](http://travis-ci.org/mafintosh/tar-fs)

## <a name="usage"></a>Utilizzo

tar-fs consente di comprimere le directory in tarball ed estrarre tarball nelle directory.

Non esegue automaticamente la compressione con gunzip, quindi se si vuole estrarre un file `.tar.gz` con questo modulo sarà necessario usare in aggiunta qualcosa come [gunzip-maybe](https://github.com/mafintosh/gunzip-maybe).

``` js
var tar = require('tar-fs')
var fs = require('fs')

// packing a directory
tar.pack('./my-directory').pipe(fs.createWriteStream('my-tarball.tar'))

// extracting a directory
fs.createReadStream('my-other-tarball.tar').pipe(tar.extract('./my-other-directory'))
```

Per ignorare vari file durante la compressione o l'estrazione, aggiungere una funzione ignore alle opzioni. `ignore` è anche un alias per `filter`. Si ottiene inoltre `header` se si usa ignore durante l'estrazione.
In questo modo è anche possibile filtrare in base ai metadati.

``` js
var pack = tar.pack('./my-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files when packing
  }
})

var extract = tar.extract('./my-other-directory', {
  ignore: function(name) {
    return path.extname(name) === '.bin' // ignore .bin files inside the tarball when extracing
  }
})

var extractFilesDirs = tar.extract('./my-other-other-directory', {
  ignore: function(_, header) {
    // pass files & directories, ignore e.g. symlinks
    return header.type !== 'file' && header.type !== 'directory'
  }
})
```

È anche possibile specificare le voci da comprimere usando l'opzione `entries`

```js
var pack = tar.pack('./my-directory', {
  entries: ['file1', 'subdir/file2'] // only the specific entries will be packed
})
```

Se si vogliono modificare le intestazioni durante la compressione/estrazione, aggiungere una funzione map alle opzioni

``` js
var pack = tar.pack('./my-directory', {
  map: function(header) {
    header.name = 'prefixed/'+header.name
    return header
  }
})

var extract = tar.extract('./my-directory', {
  map: function(header) {
    header.name = 'another-prefix/'+header.name
    return header
  }
})
```

Analogamente, è possibile usare `mapStream` nel caso si vogliano modificare i flussi di file di input/output

``` js
var pack = tar.pack('./my-directory', {
  mapStream: function(fileStream, header) {
    // NOTE: the returned stream HAS to have the same length as the input stream.
    // If not make sure to update the size in the header passed in here.
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})

var extract = tar.extract('./my-directory', {
  mapStream: function(fileStream, header) {
    if (path.extname(header.name) === '.js') {
      return fileStream.pipe(someTransform)
    }
    return fileStream;
  }
})
```

Impostare `options.fmode` e `options.dmode` per assicurarsi che i file/directory estratti abbiano le modalità corrispondenti

``` js
var extract = tar.extract('./my-directory', {
  dmode: parseInt(555, 8), // all dirs should be readable
  fmode: parseInt(444, 8) // all files should be readable
})
```

Può essere utile usare `dmode` e `fmode` se si stanno comprimendo/decomprimendo tarball tra *nix/windows, per garantire che tutti i file/directory decompressi siano leggibili.

In alternativa, è possibile impostare `options.readable` e/o `options.writable` per impostare dmode e fmode su leggibile/scrivibile.

``` js
var extract = tar.extract('./my-directory', {
  readable: true, // all dirs and files should be readable
  writable: true, // all dirs and files should be writable
})
```

Impostare `options.strict` su `false` se si vogliono ignorare gli errori dovuti a tipi di voce non supportati (ad esempio file di dispositivo)

Per dereferenziare i collegamenti simbolici (comprimere il contenuto del collegamento simbolico anziché il collegamento stesso), impostare `options.dereference` su `true`.

## <a name="copy-a-directory"></a>Copiare una directory

La copia di una directory con autorizzazioni e mtime intact è molto semplice:

``` js
tar.pack('source-directory').pipe(tar.extract('dest-directory'))
```

## <a name="interaction-with-tar-stream"></a>Interazione con [`tar-stream`](https://github.com/mafintosh/tar-stream)

Usare `finalize: false` e l'hook `finish` per lasciare aperto il flusso di compressione per altre voci (vedere [`tar-stream#pack`](https://github.com/mafintosh/tar-stream#packing)) e usare `pack` per passare un flusso di compressione esistente.

``` js
var mypack = tar.pack('./my-directory', {
  finalize: false,
  finish: function(sameAsMypack) {
    mypack.entry({name: 'generated-file.txt'}, "hello")
    tar.pack('./other-directory', {
      pack: sameAsMypack
    })
  }
})
```


## <a name="performance"></a>Prestazioni

La compressione e l'estrazione di 6,1 GB con 2496 directory e 2398 file producono i risultati seguenti nel mio Macbook Air.
[Vedere il benchmark qui](https://gist.github.com/mafintosh/8102201)

* tar-fs: 34,261 secondi
* [node-tar](https://github.com/isaacs/node-tar): 366,123 secondi (10 volte più lento)

## <a name="license"></a>Licenza

MIT
