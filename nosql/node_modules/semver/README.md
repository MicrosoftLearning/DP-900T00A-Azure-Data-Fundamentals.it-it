---
ms.openlocfilehash: 496981207a34eb019688e8f2583ccc1abcbb5bce
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/05/2022
ms.locfileid: "138050954"
---
<a name="semver1----the-semantic-versioner-for-npm"></a>semver(1) - Strumento di versionamento semantico per npm
===========================================

## <a name="install"></a>Installazione

```bash
npm install --save semver
````

## <a name="usage"></a>Utilizzo

Come modulo di node:

```js
const semver = require('semver')

semver.valid('1.2.3') // '1.2.3'
semver.valid('a.b.c') // null
semver.clean('  =v1.2.3   ') // '1.2.3'
semver.satisfies('1.2.3', '1.x || >=2.5.0 || 5.0.0 - 7.2.3') // true
semver.gt('1.2.3', '9.8.7') // false
semver.lt('1.2.3', '9.8.7') // true
semver.minVersion('>=1.0.0') // '1.0.0'
semver.valid(semver.coerce('v2')) // '2.0.0'
semver.valid(semver.coerce('42.6.7.9.3-alpha')) // '42.6.7'
```

Come utilità della riga di comando:

```
$ semver -h

A JavaScript implementation of the https://semver.org/ specification
Copyright Isaac Z. Schlueter

Usage: semver [options] <version> [<version> [...]]
Prints valid versions sorted by SemVer precedence

Options:
-r --range <range>
        Print versions that match the specified range.

-i --increment [<level>]
        Increment a version by the specified level.  Level can
        be one of: major, minor, patch, premajor, preminor,
        prepatch, or prerelease.  Default level is 'patch'.
        Only one version may be specified.

--preid <identifier>
        Identifier to be used to prefix premajor, preminor,
        prepatch or prerelease version increments.

-l --loose
        Interpret versions and ranges loosely

-p --include-prerelease
        Always include prerelease versions in range matching

-c --coerce
        Coerce a string into SemVer if possible
        (does not imply --loose)

Program exits successfully if any valid version satisfies
all supplied ranges, and prints all satisfying versions.

If no satisfying versions are found, then exits failure.

Versions are printed in ascending order, so supplying
multiple versions to the utility will just sort them.
```

## <a name="versions"></a>Versioni

Il concetto di "versione" è descritto dalla specifica `v2.0.0` disponibile all'indirizzo <https://semver.org/>.

Un carattere `"="` o `"v"` viene rimosso e ignorato.

## <a name="ranges"></a>Intervalli

Un `version range` è un set di `comparators` che specificano versioni corrispondenti all'intervallo.

Un `comparator` è composto da un `operator` e una `version`.  Il set di `operators` primitivi è:

* `<` Minore di
* `<=` Minore o uguale a
* `>` Maggiore di
* `>=` Maggiore o uguale a
* `=` Uguale a.  Se non viene specificato alcun operatore, si presuppone l'uguaglianza, quindi questo operatore è facoltativo, ma PUÒ essere incluso.

Ad esempio, il comparatore `>=1.2.7` corrisponderebbe alle versioni `1.2.7`, `1.2.8`, `2.5.3` e `1.3.9`, ma non alle versioni `1.2.6` o `1.1.0`.

I comparatori possono essere uniti tramite spazi vuoti per formare un `comparator set`, soddisfatto dall'**intersezione** di tutti i comparatori inclusi.

Un intervallo è costituito da uno o più set di comparatori, uniti con `||`.  Una versione corrisponde a un intervallo se e solo se ogni comparatore in almeno uno dei set di comparatori separati da `||`viene soddisfatto dalla versione.

Ad esempio, l'intervallo `>=1.2.7 <1.3.0` corrisponde alle versioni `1.2.7`, `1.2.8` e `1.2.99`, ma non alle versioni `1.2.6`, `1.3.0` o `1.1.0`.

L'intervallo `1.2.7 || >=1.2.9 <2.0.0` corrisponde alle versioni `1.2.7`, `1.2.9` e `1.4.6`, ma non alle versioni `1.2.8` o `2.0.0`.

### <a name="prerelease-tags"></a>Tag di versione preliminare

Se una versione ha un tag di versione preliminare, ad esempio `1.2.3-alpha.3`, sarà consentito soddisfare i set di comparatori solo se anche almeno un comparatore con la stessa tupla `[major, minor, patch]` ha un tag di versione preliminare.

Ad esempio, l'intervallo `>1.2.3-alpha.3` potrebbe corrispondere alla versione `1.2.3-alpha.7`, ma *non* sarebbe soddisfatto da `3.4.5-alpha.9`, anche se `3.4.5-alpha.9` è tecnicamente "maggiore di" `1.2.3-alpha.3` secondo le regole di ordinamento semver.  L'intervallo di versioni accetta tag di versione preliminare solo per la versione `1.2.3`.  La versione `3.4.5` *soddisferebbe* l'intervallo, perché non ha un flag di versione preliminare e `3.4.5` è maggiore di `1.2.3-alpha.7`.

Lo scopo di questo comportamento è duplice.  Prima di tutto, le versioni preliminari vengono spesso aggiornate molto rapidamente e contengono molte modifiche che causano un'interruzione e sono (come da progettazione dell'autore) non ancora adatte all'uso pubblico.
Pertanto, per impostazione predefinita, vengono escluse dalla semantica di corrispondenza dell'intervallo.

In secondo luogo, un utente che acconsente esplicitamente a usare una versione preliminare indica chiaramente l'intento di usare *tale set specifico* di versioni alfa/beta/rc.  Includendo un tag di versione preliminare nell'intervallo, l'utente indica che è consapevole del rischio.  Tuttavia, non è comunque appropriato presupporre che abbia acconsentito esplicitamente ad assumersi un rischio simile nel set *successivo* di versioni preliminari.

Si noti che questo comportamento può essere eliminato (trattando tutte le versioni preliminari come se fossero versioni normali, per gli scopi della corrispondenza dell'intervallo) impostando il flag `includePrerelease` per l'oggetto opzioni su qualsiasi [funzione](https://github.com/npm/node-semver#functions) che esegue la corrispondenza degli intervalli.

#### <a name="prerelease-identifiers"></a>Identificatori di versione preliminare

Il metodo `.inc` accetta un argomento stringa `identifier` aggiuntivo che aggiungerà il valore della stringa come identificatore di versione preliminare:

```javascript
semver.inc('1.2.3', 'prerelease', 'beta')
// '1.2.4-beta.0'
```

Esempio di riga di comando:

```bash
$ semver 1.2.3 -i prerelease --preid beta
1.2.4-beta.0
```

Che può quindi essere usato per ulteriori incrementi:

```bash
$ semver 1.2.4-beta.0 -i prerelease
1.2.4-beta.1
```

### <a name="advanced-range-syntax"></a>Sintassi avanzata per gli intervalli

La sintassi avanzata per gli intervalli prevede il desugaring con l'utilizzo dei comparatori primitivi in modi deterministici.

Gli intervalli avanzati possono essere combinati nello stesso modo dei comparatori primitivi usando spazi vuoti o `||`.

#### <a name="hyphen-ranges-xyz---abc"></a>Intervalli con trattini `X.Y.Z - A.B.C`

Specifica un set inclusivo.

* `1.2.3 - 2.3.4` := `>=1.2.3 <=2.3.4`

Se viene fornita una versione parziale come prima versione nell'intervallo inclusivo, i pezzi mancanti vengono sostituiti con zeri.

* `1.2 - 2.3.4` := `>=1.2.0 <=2.3.4`

Se viene fornita una versione parziale come seconda versione nell'intervallo inclusivo, tutte le versioni che iniziano con le parti specificate della tupla vengono accettate, ma niente che risulterebbe maggiore delle parti della tupla specificate.

* `1.2.3 - 2.3` := `>=1.2.3 <2.4.0`
* `1.2.3 - 2` := `>=1.2.3 <3.0.0`

#### <a name="x-ranges-12x-1x-12-"></a>Intervalli X `1.2.x` `1.X` `1.2.*` `*`

È possibile usare `X`, `x` o `*` per sostituire uno dei valori numerici nella tupla `[major, minor, patch]`.

* `*` := `>=0.0.0` (qualsiasi versione)
* `1.x` := `>=1.0.0 <2.0.0` (versione principale)
* `1.2.x` := `>=1.2.0 <1.3.0` (versioni principale e secondaria)

Un intervallo di versioni parziale viene considerato come un intervallo X, quindi il carattere speciale è in effetti facoltativo.

* `""` (stringa vuota) := `*` := `>=0.0.0`
* `1` := `1.x.x` := `>=1.0.0 <2.0.0`
* `1.2` := `1.2.x` := `>=1.2.0 <1.3.0`

#### <a name="tilde-ranges-123-12-1"></a>Intervalli con tilde `~1.2.3` `~1.2` `~1`

Consente modifiche a livello di patch se viene specificata una versione secondaria per il comparatore.  Consente modifiche di livello secondario in caso contrario.

* `~1.2.3` := `>=1.2.3 <1.(2+1).0` := `>=1.2.3 <1.3.0`
* `~1.2` := `>=1.2.0 <1.(2+1).0` := `>=1.2.0 <1.3.0` (equivale a `1.2.x`)
* `~1` := `>=1.0.0 <(1+1).0.0` := `>=1.0.0 <2.0.0` (equivale a `1.x`)
* `~0.2.3` := `>=0.2.3 <0.(2+1).0` := `>=0.2.3 <0.3.0`
* `~0.2` := `>=0.2.0 <0.(2+1).0` := `>=0.2.0 <0.3.0` (equivale a `0.2.x`)
* `~0` := `>=0.0.0 <(0+1).0.0` := `>=0.0.0 <1.0.0` (equivale a `0.x`)
* `~1.2.3-beta.2` := `>=1.2.3-beta.2 <1.3.0` Si noti che le versioni preliminari nella versione `1.2.3` saranno consentite, se sono maggiori o uguali a `beta.2`.  Quindi, la versione `1.2.3-beta.4` sarebbe consentita, diversamente da `1.2.4-beta.2`, perché è una versione preliminare di una tupla `[major, minor, patch]` diversa.

#### <a name="caret-ranges-123-025-004"></a>Intervalli con accento circonflesso `^1.2.3` `^0.2.5` `^0.0.4`

Consente modifiche che non modificano la cifra più a sinistra diversa da zero nella tupla `[major, minor, patch]`.  In altre parole, consente aggiornamenti patch e secondari per le versioni `1.0.0` e successive, gli aggiornamenti delle patch per le versioni `0.X >=0.1.0` e *nessun* aggiornamento per le versioni `0.0.X`.

Molti autori considerano una versione `0.x` come se la `x` rappresentasse l'indicatore principale di modifica che causa un'interruzione.

Gli intervalli con accento circonflesso sono ideali quando un autore potrebbe introdurre modifiche che causano un'interruzione tra le versioni `0.2.4` e `0.3.0`, che è una pratica comune.
Tuttavia, si presuppone che *non* ci saranno modifiche che causano un'interruzione tra `0.2.4` e `0.2.5`.  Consente di apportare modifiche che si presuppone siano additive (ma che non causano un'interruzione), secondo le pratiche comunemente applicate.

* `^1.2.3` := `>=1.2.3 <2.0.0`
* `^0.2.3` := `>=0.2.3 <0.3.0`
* `^0.0.3` := `>=0.0.3 <0.0.4`
* `^1.2.3-beta.2` := `>=1.2.3-beta.2 <2.0.0` Si noti che le versioni preliminari nella versione `1.2.3` saranno consentite, se sono maggiori o uguali a `beta.2`.  Quindi, la versione `1.2.3-beta.4` sarebbe consentita, diversamente da `1.2.4-beta.2`, perché è una versione preliminare di una tupla `[major, minor, patch]` diversa.
* `^0.0.3-beta` := `>=0.0.3-beta <0.0.4` Si noti che le versioni preliminari nella versione `0.0.3` saranno consentite *solo* se sono maggiori o uguali a `beta`.  `0.0.3-pr.2` sarebbe quindi consentita.

Durante l'analisi degli intervalli con accento circonflesso, un valore `patch` mancante causa il desugaring al numero `0`, ma consentirà flessibilità all'interno di tale valore, anche se le versioni principale e secondaria sono entrambe `0`.

* `^1.2.x` := `>=1.2.0 <2.0.0`
* `^0.0.x` := `>=0.0.0 <0.1.0`
* `^0.0` := `>=0.0.0 <0.1.0`

I valori `minor` e `patch` mancanti causeranno il desugaring a zero, ma consentono anche flessibilità all'interno di tali valori, anche se la versione principale è zero.

* `^1.x` := `>=1.0.0 <2.0.0`
* `^0.x` := `>=0.0.0 <1.0.0`

### <a name="range-grammar"></a>Grammatica per gli intervalli

Per mettere insieme tutto questo, ecco una grammatica Backus-Naur per gli intervalli, a vantaggio degli autori di parser:

```bnf
range-set  ::= range ( logical-or range ) *
logical-or ::= ( ' ' ) * '||' ( ' ' ) *
range      ::= hyphen | simple ( ' ' simple ) * | ''
hyphen     ::= partial ' - ' partial
simple     ::= primitive | partial | tilde | caret
primitive  ::= ( '<' | '>' | '>=' | '<=' | '=' ) partial
partial    ::= xr ( '.' xr ( '.' xr qualifier ? )? )?
xr         ::= 'x' | 'X' | '*' | nr
nr         ::= '0' | ['1'-'9'] ( ['0'-'9'] ) *
tilde      ::= '~' partial
caret      ::= '^' partial
qualifier  ::= ( '-' pre )? ( '+' build )?
pre        ::= parts
build      ::= parts
parts      ::= part ( '.' part ) *
part       ::= nr | [-0-9A-Za-z]+
```

## <a name="functions"></a>Funzioni

Tutti i metodi e le classi accettano un argomento oggetto `options` finale.  Tutte le opzioni in questo oggetto sono `false` per impostazione predefinita.  Le opzioni supportate sono:

- `loose` Per essere più flessibili per le stringhe semver non del tutto valide.
  (Qualsiasi output risultante sarà sempre conforme al 100% naturalmente.)  Per motivi di compatibilità con le versioni precedenti, se l'argomento `options` è un valore booleano anziché un oggetto, viene interpretato come parametro `loose`.
- `includePrerelease` Impostare per evitare il [comportamento predefinito](https://github.com/npm/node-semver#prerelease-tags) che prevede l'esclusione delle versioni con tag di versione preliminare dagli intervalli, a meno che non si acconsenta esplicitamente.

I comparatori e gli intervalli in modalità strict saranno rigorosi per le stringhe semver analizzate.

* `valid(v)`: restituisce la versione analizzata o Null se non è valida.
* `inc(v, release)`: restituisce la versione incrementata dal tipo di release (`major`, `premajor`, `minor`, `preminor`, `patch`, `prepatch` o `prerelease`) o Null se non è valida
  * `premajor` in una chiamata incrementerà la versione alla versione principale successiva e a una versione preliminare di tale versione principale.
    `preminor` e `prepatch` funzionano entrambi allo stesso modo.
  * Se la chiamata viene eseguita da una versione non preliminare, `prerelease` funzionerà allo stesso modo di `prepatch`. Incrementa la versione della patch, quindi crea una versione preliminare. Se la versione di input è già una versione preliminare, viene semplicemente incrementata.
* `prerelease(v)`: restituisce una matrice dei componenti preliminari o Null se non esistono. Esempio: `prerelease('1.2.3-alpha.1') -> ['alpha', 1]`
* `major(v)`: restituisce il numero di versione principale.
* `minor(v)`: restituisce il numero di versione secondario.
* `patch(v)`: restituisce il numero di versione patch.
* `intersects(r1, r2, loose)`: restituisce true se i due intervalli o i comparatori specificati si intersecano.
* `parse(v)`: tenta di analizzare una stringa come versione semantica, restituendo un oggetto `SemVer` o `null`.

### <a name="comparison"></a>Confronto

* `gt(v1, v2)`: `v1 > v2`
* `gte(v1, v2)`: `v1 >= v2`
* `lt(v1, v2)`: `v1 < v2`
* `lte(v1, v2)`: `v1 <= v2`
* `eq(v1, v2)`: `v1 == v2` true se sono logicamente equivalenti, anche se non sono esattamente la stessa stringa.  Si è già appreso come confrontare le stringhe.
* `neq(v1, v2)`: `v1 != v2` opposto di `eq`.
* `cmp(v1, comparator, v2)`: passa una stringa di confronto e chiamerà la funzione corrispondente precedente.  `"==="` e `"!=="` eseguono un semplice confronto tra stringhe, ma sono incluse per completezza.  Genera un'eccezione se viene specificata una stringa di confronto non valida.
* `compare(v1, v2)`: restituisce `0` se `v1 == v2` o `1` se `v1` è maggiore o `-1` se `v2` è maggiore.  Applica l'ordinamento crescente se passato a `Array.sort()`.
* `rcompare(v1, v2)`: il contrario di compare.  Ordina una matrice di versioni in ordine decrescente quando viene passato a `Array.sort()`.
* `diff(v1, v2)`: restituisce la differenza tra due versioni in base al tipo di versione (`major`, `premajor`, `minor`, `preminor`, `patch`, `prepatch` o `prerelease`) o Null se le versioni sono uguali.

### <a name="comparators"></a>Comparatori

* `intersects(comparator)`: restituisce true se i comparatori si intersecano

### <a name="ranges"></a>Intervalli

* `validRange(range)`: restituisce l'intervallo valido o Null se non è valido
* `satisfies(version, range)`: restituisce true se la versione soddisfa l'intervallo.
* `maxSatisfying(versions, range)`: restituisce la versione più alta nell'elenco che soddisfa l'intervallo oppure `null` se nessuna di esse soddisfa l'intervallo.
* `minSatisfying(versions, range)`: restituisce la versione più bassa nell'elenco che soddisfa l'intervallo oppure `null` se nessuna di esse soddisfa l'intervallo.
* `minVersion(range)`: restituisce la versione più bassa che può corrispondere all'intervallo specificato.
* `gtr(version, range)`: restituisce `true` se la versione è maggiore di tutte le versioni possibili nell'intervallo.
* `ltr(version, range)`: restituisce `true` se la versione è minore di tutte le versioni possibili nell'intervallo.
* `outside(version, range, hilo)`: restituisce true se la versione non rientra nei limiti dell'intervallo nella direzione alta o bassa.  L'argomento `hilo` deve essere la stringa `'>'` o `'<'`.  (Questa è la funzione chiamata da `gtr` e `ltr`.)
* `intersects(range)`: restituisce true se uno dei comparatori degli intervalli si interseca

Si noti che, poiché gli intervalli potrebbero non essere contigui, una versione potrebbe non essere maggiore di un intervallo, minore di un intervallo *o* soddisfare un intervallo.  Ad esempio, l'intervallo `1.2 <1.2.9 || >2.0.0` avrà un buco da `1.2.9` fino a `2.0.0`, quindi la versione `1.2.10` non sarebbe maggiore dell'intervallo (perché soddisfa `2.0.1`, che è superiore), né minore dell'intervallo (poiché soddisfa `1.2.8`, che è inferiore) e non soddisfa neanche l'intervallo.

Se si vuole sapere se una versione soddisfa o non soddisfa un intervallo, usare la funzione `satisfies(version, range)`.

### <a name="coercion"></a>Coercizione

* `coerce(version)`: forza semver per una stringa, se possibile

L'obiettivo è fornire una conversione molto permissiva di una stringa non semver a semver. Cerca la prima cifra in una stringa e utilizza tutti i caratteri rimanenti che soddisfano almeno un semver parziale (ad esempio, `1`, `1.2`, `1.2.3`) fino alla lunghezza massima consentita (256 caratteri).  Le versioni più lunghe vengono semplicemente troncate (`4.6.3.9.2-alpha2` diventa `4.6.3`).  Tutto il testo circostante viene semplicemente ignorato (`v3.4 replaces v3.3.1` diventa `3.4.0`).  La coercizione non verrà applicata solo al testo senza cifre (`version one` non è valido).  La lunghezza massima per qualsiasi componente semver considerato per la coercizione è di 16 caratteri. I componenti più lunghi verranno ignorati (`10000000000000000.4.7.4` diventa `4.7.4`).  Il valore massimo per qualsiasi componente semver è `Number.MAX_SAFE_INTEGER || (2**53 - 1)`. I componenti con valore maggiore non sono validi (`9999999999999999.4.7.4` è probabile che non sia valido).
