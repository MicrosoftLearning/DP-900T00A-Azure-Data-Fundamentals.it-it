---
ms.openlocfilehash: 79b8bd5d8af7fd6d79dcb7c24b3f2e03e1d2a029
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051667"
---
# <a name="ansi-regex-build-statushttpstravis-ciorgchalkansi-regex"></a>ansi-regex [![Stato della compilazione](https://travis-ci.org/chalk/ansi-regex.svg?branch=master)](https://travis-ci.org/chalk/ansi-regex)

> Espressione regolare per la corrispondenza dei [codici di escape ANSI](http://en.wikipedia.org/wiki/ANSI_escape_code)


## <a name="install"></a>Installazione

```
$ npm install --save ansi-regex
```


## <a name="usage"></a>Utilizzo

```js
const ansiRegex = require('ansi-regex');

ansiRegex().test('\u001b[4mcake\u001b[0m');
//=> true

ansiRegex().test('cake');
//=> false

'\u001b[4mcake\u001b[0m'.match(ansiRegex());
//=> ['\u001b[4m', '\u001b[0m']
```

## <a name="faq"></a>Domande frequenti

### <a name="why-do-you-test-for-codes-not-in-the-ecma-48-standard"></a>Perché vengono testati codici non conformi allo standard ECMA 48?

Alcuni dei codici eseguiti come test sono codici acquisiti durante la ricerca di vari elenchi di codici non standard o specifici del produttore. Vengono testati sia codici standard che non standard, perché la maggior parte di essi ha lo stesso formato o un formato simile e la corrispondenza può essere verificata in modo sicuro nelle stringhe senza il rischio di rimuovere il contenuto effettivo delle stringhe. Vi sono alcuni codici di controllo non standard che non seguono il formato tradizionale (ad esempio, terminano in numeri) e rendono quindi necessario escluderli dal test perché non è possibile verificare la corrispondenza in modo affidabile.

Dal punto di vista storico, tali standard ECMA sono stati stabiliti nei primi anni '90, mentre VT100, ad esempio, è stato progettato verso la metà o la fine degli anni '70. In quel momento, i codici di controllo erano ancora piuttosto non gestiti e i tecnici li usavano per un'ampia varietà di scopi, ad esempio per attivare porte hardware che potevano essere proprietarie. Un'altra area in cui si osserva una simile "anarchia" di codici è l'architettura x86 per i processori: vi sono molti "interrupt" che possono avere diversi significati per determinati marchi di processori, la maggior parte dei quali è stata eliminata.


## <a name="license"></a>Licenza

MIT © [Sindre Sorhus](http://sindresorhus.com)
