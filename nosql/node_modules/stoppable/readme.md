---
ms.openlocfilehash: 03ad292b1fceecb8974f1d8753cb47723344dbf3
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051587"
---
# <a name="stoppable"></a>Stoppable

[![Stato della compilazione](https://travis-ci.org/hunterloftis/stoppable.svg?branch=master)](https://travis-ci.org/hunterloftis/stoppable)

> `server.close()` di Node è probabilmente il [funzionamento previsto per impostazione predefinita](https://github.com/nodejs/node/issues/2642).

## <a name="summary"></a>Riepilogo

```js
const server = stoppable(http.createServer(handler))
server.stop()
```

Stoppable smette di accettare nuove connessioni e chiude le connessioni esistenti inattive (inclusi i keep-alive) senza interrompere le richieste in esecuzione.

## <a name="requirements"></a>Requisiti

- Node.js v6+

Node.js v4.x è supportato *in modo non ufficiale*.

## <a name="installation"></a>Installazione

```bash
yarn add stoppable
```

(o usare npm)

## <a name="usage"></a>Utilizzo

**costruttore**

```js
stoppable(server, grace)
```

Decora l'istanza del server con un metodo `stop`.
Restituisce l'istanza del server, in modo che possa essere concatenata o possa essere eseguita come istruzione autonoma.

- server: qualsiasi istanza di server HTTP o HTTPS
- grace: millisecondi di attesa prima di forzare la chiusura delle connessioni

Il valore predefinito di `grace` è Infinity (la chiusura non viene forzata).
Se si vogliono terminare immediatamente tutti i socket, è possibile usare il valore 0 per grace.

**stop()**

```js
server.stop(callback)
```

Chiude il server.

- callback: passato alla funzione esistente `server.close` per registrare automaticamente un evento 'close'.
Il primo argomento è un errore e il secondo argomento è un valore booleano che indica se l'arresto è avvenuto normalmente.

## <a name="design-decisions"></a>Decisioni relative alla progettazione

- Il monkey-patching richiede in genere un sacco di risorse, ma in questo caso è l'API migliore. Vediamola come una "decorazione".
- È possibile specificare `grace` per `stop`, ma è preferibile adeguarsi all'API esistente `server.close`.
- I client devono essere gestiti rispettosamente, quindi non distruggiamo semplicemente i socket, ma inviamo prima pacchetti `FIN`.
- Qualsiasi soluzione a questo problema richiede di tracciare ogni connessione e richiesta/risposta.
Eseguiamo il minimo di lavoro su questi percorsi di codice "caldi" ritardando il più possibile fino al metodo `stop` effettivo.

## <a name="performance"></a>Prestazioni

Non è possibile fornire questa funzionalità senza tracciare la connessione, la disconnessione, la richiesta e la risposta.
Stoppable, tuttavia, fa di tutto per eseguire il minimo del lavoro nei percorsi di codice caldi e per usare strutture di dati ottimali.

Sarei interessato a vedere benchmark di prestazioni reali; il benchmark dell'artiglieria di loopback semplice incluso in questa libreria mostra un overhead molto ridotto per l'uso di un server arrestabile:

### <a name="without-stoppable"></a>Senza Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 939.85
  Request latency:
    min: 0.5
    max: 51.3
    median: 2.1
    p95: 3.7
    p99: 15.3
  Scenario duration:
    min: 1
    max: 60.7
    median: 3.6
    p95: 7.6
    p99: 19
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

### <a name="with-stoppable"></a>Con Stoppable

```plain
  Scenarios launched:  10000
  Scenarios completed: 10000
  Requests completed:  10000
  RPS sent: 940.73
  Request latency:
    min: 0.5
    max: 43.4
    median: 2.1
    p95: 3.8
    p99: 15.5
  Scenario duration:
    min: 1.1
    max: 57
    median: 3.7
    p95: 8
    p99: 19.4
  Scenario counts:
    0: 10000 (100%)
  Codes:
    200: 10000
```

## <a name="license"></a>Licenza

MIT