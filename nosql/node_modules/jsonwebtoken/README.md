---
ms.openlocfilehash: c0d4bfc80d62125554d466fe2b45375ed815b043
ms.sourcegitcommit: e739004291428ce83f14b9d49f1e9dfaa3762dde
ms.translationtype: HT
ms.contentlocale: it-IT
ms.lasthandoff: 02/05/2022
ms.locfileid: "138051476"
---
# <a name="jsonwebtoken"></a>jsonwebtoken

| **Compila** | **Dipendenza** |
|-----------|---------------|
| [![Stato della compilazione](https://secure.travis-ci.org/auth0/node-jsonwebtoken.svg?branch=master)](http://travis-ci.org/auth0/node-jsonwebtoken) | [![Stato della dipendenza](https://david-dm.org/auth0/node-jsonwebtoken.svg)](https://david-dm.org/auth0/node-jsonwebtoken) |


Implementazione di [JSON Web Token](https://tools.ietf.org/html/rfc7519).

È stato sviluppato in base a `draft-ietf-oauth-json-web-token-08` e usa [node-jws](https://github.com/brianloveswords/node-jws).

# <a name="install"></a>Installazione

```bash
$ npm install jsonwebtoken
```

# <a name="migration-notes"></a>Note sulla migrazione

* [Da v7 a v8](https://github.com/auth0/node-jsonwebtoken/wiki/Migration-Notes:-v7-to-v8)

# <a name="usage"></a>Utilizzo

### <a name="jwtsignpayload-secretorprivatekey-options-callback"></a>jwt.sign(payload, secretOrPrivateKey, [options, callback])

(Asincrono) Se viene fornito un callback, questo viene chiamato con `err` o con il token JWT.

(Sincrono) Restituisce JsonWebToken come stringa

`payload` può essere un valore letterale di oggetto, un buffer o una stringa che rappresenta un JSON valido. 
> **Si _noti_ che** `exp` o qualsiasi altra attestazione viene impostata solo se il payload è un valore letterale di oggetto. La validità JSON dei payload buffer o stringa non viene verificata.

> Se `payload` non è un buffer o una stringa, viene forzato in una stringa usando `JSON.stringify`.

`secretOrPrivateKey` è una stringa, un buffer o un oggetto contenente il segreto per gli algoritmi HMAC o la chiave privata con codifica PEM per gli algoritmi RSA e ECDSA. In caso di chiave privata con passphrase è possibile usare un oggetto `{ key, passphrase }` (in base alla [documentazione relativa alla crittografia](https://nodejs.org/api/crypto.html#crypto_sign_sign_private_key_output_format)). In tal caso assicurarsi di passare l'opzione `algorithm`.

`options`:

* `algorithm` (impostazione predefinita: `HS256`)
* `expiresIn`: espresso in secondi o con una stringa che descrive un intervallo di tempo [zeit/ms](https://github.com/zeit/ms). 
  > Esempio: `60`, `"2 days"`, `"10h"`, `"7d"`. Un valore numerico viene interpretato come conteggio dei secondi. Se si usa una stringa, specificare le unità di tempo (giorni, ore e così via); in caso contrario viene usata l'unità millisecondi per impostazione predefinita (`"120"` è uguale a `"120ms"`).
* `notBefore`: espresso in secondi o con una stringa che descrive un intervallo di tempo [zeit/ms](https://github.com/zeit/ms). 
  > Esempio: `60`, `"2 days"`, `"10h"`, `"7d"`. Un valore numerico viene interpretato come conteggio dei secondi. Se si usa una stringa, specificare le unità di tempo (giorni, ore e così via); in caso contrario viene usata l'unità millisecondi per impostazione predefinita (`"120"` è uguale a `"120ms"`).
* `audience`
* `issuer`
* `jwtid`
* `subject`
* `noTimestamp`
* `header`
* `keyid`
* `mutatePayload`: se true, la funzione di firma modifica direttamente l'oggetto payload. Risulta utile se è necessario un riferimento non elaborato al payload dopo l'applicazione delle attestazioni, ma prima che sia stato codificato in un token.



> Non sono previsti valori predefiniti per questo `expiresIn`, `notBefore`, `audience`, `subject`, `issuer`.  Le attestazioni possono anche essere fornite direttamente nel payload, rispettivamente con `exp`, `nbf`, `aud`, `sub` e `iss`, ma **_non è possibile_** includerle in entrambe le posizioni.

Tenere presente che `exp`, `nbf` e `iat` sono **NumericDate**. Vedere in proposito [Scadenza token (attestazione exp)](#token-expiration-exp-claim).


L'intestazione può essere personalizzata tramite l'oggetto `options.header`.

I token JWT generati includono per impostazione predefinita un'attestazione `iat` (rilasciata), a meno che non venga specificato `noTimestamp`. Se `iat` viene inserito nel payload, verrà usato invece del timestamp reale per calcolare altri elementi come `exp` dato un intervallo di tempo in `options.expiresIn`.

Segno sincrono con impostazione predefinita (HMAC SHA256)

```js
var jwt = require('jsonwebtoken');
var token = jwt.sign({ foo: 'bar' }, 'shhhhh');
```

Segno sincrono con RSA SHA256
```js
// sign with RSA SHA256
var privateKey = fs.readFileSync('private.key');
var token = jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256'});
```

Firma asincrona
```js
jwt.sign({ foo: 'bar' }, privateKey, { algorithm: 'RS256' }, function(err, token) {
  console.log(token);
});
```

Retrodatare un token JWT di 30 secondi
```js
var older_token = jwt.sign({ foo: 'bar', iat: Math.floor(Date.now() / 1000) - 30 }, 'shhhhh');
```

#### <a name="token-expiration-exp-claim"></a>Scadenza token (attestazione exp)

Lo standard per i token JWT definisce un'attestazione `exp` per la scadenza. La scadenza è rappresentata come oggetto **NumericDate**:

> Valore numerico JSON che rappresenta il numero di secondi trascorsi dalla mezzanotte del 1° gennaio 1970 fino alla data/ora UTC specificata, ignorando i secondi intercalari.  Questo equivale alla definizione IEEE Std 1003.1, 2013 Edition [POSIX.1] "secondi dall'epoca", in cui ogni giorno è costituito esattamente da 86.400 secondi. A parte questo, possono essere rappresentati valori non Integer.  Per informazioni dettagliate su data/ora in genere e su data/ora UTC in particolare, vedere RFC 3339 [RFC3339].

Ciò significa che il campo `exp` deve contenere il numero di secondi dall'epoca.

Firma di un token con scadenza di 1 ora:

```javascript
jwt.sign({
  exp: Math.floor(Date.now() / 1000) + (60 * 60),
  data: 'foobar'
}, 'secret');
```

Un altro modo per generare un token simile con questa libreria è:

```javascript
jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: 60 * 60 });

//or even better:

jwt.sign({
  data: 'foobar'
}, 'secret', { expiresIn: '1h' });
```

### <a name="jwtverifytoken-secretorpublickey-options-callback"></a>jwt.verify(token, secretOrPublicKey, [options, callback])

(Asincrono) Se viene fornito un callback, la funzione si comporta in modo asincrono. Il callback viene chiamato con il payload decodificato se la firma è valida e la scadenza, il gruppo di destinatari o l'autorità di certificazione facoltativa è valida. In caso contrario, verrà chiamato con l'errore.

(Sincrono) Se non viene fornito un callback, la funzione si comporta in modo sincrono. Restituisce il payload decodificato se la firma è valida e la scadenza, il gruppo di destinatari o l'autorità di certificazione facoltativa è valida. In caso contrario, genera l'errore.

`token` è la stringa JsonWebToken.

`secretOrPublicKey` è una stringa o un buffer contenente il segreto per gli algoritmi HMAC o la chiave pubblica con codifica PEM per gli algoritmi RSA e ECDSA.
Se `jwt.verify` viene chiamato in modo asincrono, `secretOrPublicKey` può essere una funzione che deve recuperare il segreto o la chiave pubblica. Per un esempio dettagliato, vedere di seguito.

Come accennato in [questo commento](https://github.com/auth0/node-jsonwebtoken/issues/208#issuecomment-231861138), esistono altre librerie che prevedono segreti con codifica base64 (byte casuali codificati con base64). In tal caso è possibile passare `Buffer.from(secret, 'base64')`; così facendo il segreto viene decodificato usando base64 e la verifica del token usa i byte casuali originali.

`options`

* `algorithms`: elenco di stringhe con i nomi degli algoritmi consentiti. Ad esempio, `["HS256", "HS384"]`.
* `audience`: per controllare il gruppo di destinatari (`aud`), specificare un valore qui. Il gruppo di destinatari può essere controllato in base a una stringa, a un'espressione regolare o a un elenco di stringhe e/o espressioni regolari. 
  > Esempio: `"urn:foo"`, `/urn:f[o]{2}/`, `[/urn:f[o]{2}/, "urn:bar"]`.
* `complete`: restituisce un oggetto con `{ payload, header, signature }` decodificato anziché solo il contenuto consueto del payload.
* `issuer` (facoltativo): stringa o matrice di stringhe di valori validi per il campo `iss`.
* `ignoreExpiration`: se `true` non convalida la scadenza del token.
* `ignoreNotBefore`...
* `subject`: per controllare il soggetto (`sub`), specificare un valore qui.
* `clockTolerance`: numero di secondi di tolleranza durante il controllo delle attestazioni `nbf` e `exp` per gestire piccole differenze di clock tra server diversi.
* `maxAge`: validità massima consentita per i token. È espressa in secondi o con una stringa che descrive un intervallo di tempo [zeit/ms](https://github.com/zeit/ms). 
  > Esempio: `1000`, `"2 days"`, `"10h"`, `"7d"`. Un valore numerico viene interpretato come conteggio dei secondi. Se si usa una stringa, specificare le unità di tempo (giorni, ore e così via); in caso contrario viene usata l'unità millisecondi per impostazione predefinita (`"120"` è uguale a `"120ms"`).
* `clockTimestamp`: tempo espresso in secondi da usare come ora corrente per tutti i confronti necessari.
* `nonce`: per controllare l'attestazione `nonce`, specificare qui un valore stringa. Viene usato in OpenID per i token ID (vedere le [note sull'implementazione di OpenID](https://openid.net/specs/openid-connect-core-1_0.html#NonceNotes)).


```js
// verify a token symmetric - synchronous
var decoded = jwt.verify(token, 'shhhhh');
console.log(decoded.foo) // bar

// verify a token symmetric
jwt.verify(token, 'shhhhh', function(err, decoded) {
  console.log(decoded.foo) // bar
});

// invalid token - synchronous
try {
  var decoded = jwt.verify(token, 'wrong-secret');
} catch(err) {
  // err
}

// invalid token
jwt.verify(token, 'wrong-secret', function(err, decoded) {
  // err
  // decoded undefined
});

// verify a token asymmetric
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, function(err, decoded) {
  console.log(decoded.foo) // bar
});

// verify audience
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo' }, function(err, decoded) {
  // if audience mismatch, err == invalid audience
});

// verify issuer
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer' }, function(err, decoded) {
  // if issuer mismatch, err == invalid issuer
});

// verify jwt id
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid' }, function(err, decoded) {
  // if jwt id mismatch, err == invalid jwt id
});

// verify subject
var cert = fs.readFileSync('public.pem');  // get public key
jwt.verify(token, cert, { audience: 'urn:foo', issuer: 'urn:issuer', jwtid: 'jwtid', subject: 'subject' }, function(err, decoded) {
  // if subject mismatch, err == invalid subject
});

// alg mismatch
var cert = fs.readFileSync('public.pem'); // get public key
jwt.verify(token, cert, { algorithms: ['RS256'] }, function (err, payload) {
  // if token alg != RS256,  err == invalid signature
});

// Verify using getKey callback
// Example uses https://github.com/auth0/node-jwks-rsa as a way to fetch the keys.
var jwksClient = require('jwks-rsa');
var client = jwksClient({
  jwksUri: 'https://sandrino.auth0.com/.well-known/jwks.json'
});
function getKey(header, callback){
  client.getSigningKey(header.kid, function(err, key) {
    var signingKey = key.publicKey || key.rsaPublicKey;
    callback(null, signingKey);
  });
}

jwt.verify(token, getKey, options, function(err, decoded) {
  console.log(decoded.foo) // bar
});

```

### <a name="jwtdecodetoken--options"></a>jwt.decode(token [, options])

(Sincrono) Restituisce il payload decodificato senza verificare se la firma è valida.

> __Avviso:__ __non__ verifica la validità della firma. __Non__ usare per i messaggi non attendibili. È invece consigliabile usare `jwt.verify`.

`token` è la stringa JsonWebToken.

`options`:

* `json`: forza JSON.parse sul payload anche se l'intestazione non contiene `"typ":"JWT"`.
* `complete`: restituisce un oggetto con il payload e l'intestazione decodificati.

Esempio

```js
// get the decoded payload ignoring signature, no secretOrPrivateKey needed
var decoded = jwt.decode(token);

// get the decoded payload and header
var decoded = jwt.decode(token, {complete: true});
console.log(decoded.header);
console.log(decoded.payload)
```

## <a name="errors--codes"></a>Errori e codici
Possibili errori generati durante la verifica.
L'errore è il primo argomento del callback di verifica.

### <a name="tokenexpirederror"></a>TokenExpiredError

Errore generato se il token è scaduto.

Oggetto errore:

* name: 'TokenExpiredError'
* message: 'jwt expired'
* expiredAt: [ExpDate]

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'TokenExpiredError',
        message: 'jwt expired',
        expiredAt: 1408621000
      }
    */
  }
});
```

### <a name="jsonwebtokenerror"></a>JsonWebTokenError
Oggetto errore:

* name: 'JsonWebTokenError'
* messaggio:
  * 'jwt malformed'
  * 'jwt signature is required'
  * 'invalid signature'
  * 'jwt audience invalid. expected: [OPTIONS AUDIENCE]'
  * 'jwt issuer invalid. expected: [OPTIONS ISSUER]'
  * 'jwt id invalid. expected: [OPTIONS JWT ID]'
  * 'jwt subject invalid. expected: [OPTIONS SUBJECT]'

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'JsonWebTokenError',
        message: 'jwt malformed'
      }
    */
  }
});
```

### <a name="notbeforeerror"></a>NotBeforeError
Generato se l'ora corrente è anteriore all'attestazione nbf.

Oggetto errore:

* name: 'NotBeforeError'
* message: 'jwt not active'
* date: 2018-10-04T16:10:44.000Z

```js
jwt.verify(token, 'shhhhh', function(err, decoded) {
  if (err) {
    /*
      err = {
        name: 'NotBeforeError',
        message: 'jwt not active',
        date: 2018-10-04T16:10:44.000Z
      }
    */
  }
});
```


## <a name="algorithms-supported"></a>Algoritmi supportati

Matrice di algoritmi supportati. Sono attualmente supportati gli algoritmi seguenti.

Valore del parametro alg | Firma digitale o algoritmo MAC
----------------|----------------------------
HS256 | HMAC che usa l'algoritmo hash SHA-256
HS384 | HMAC che usa l'algoritmo hash SHA-384
HS512 | HMAC che usa l'algoritmo hash SHA-512
RS256 | RSASSA-PKCS1-v1_5 che usa l'algoritmo hash SHA-256
RS384 | RSASSA-PKCS1-v1_5 che usa l'algoritmo hash SHA-384
RS512 | RSASSA-PKCS1-v1_5 che usa l'algoritmo hash SHA-512
PS256 | RSASSA-PSS che usa l'algoritmo hash SHA-256 (solo il nodo ^6.12.0 OR >=8.0.0)
PS384 | RSASSA-PSS che usa l'algoritmo hash SHA-384 (solo il nodo ^6.12.0 OR >=8.0.0)
PS512 | RSASSA-PSS che usa l'algoritmo hash SHA-512 (solo il nodo ^6.12.0 OR >=8.0.0)
ES256 | ECDSA che usa la curva P-256 e l'algoritmo hash SHA-256
ES384 | ECDSA che usa la curva P-384 e l'algoritmo hash SHA-384
ES512 | ECDSA che usa la curva P-521 e l'algoritmo hash SHA-512
Nessuno | Nessuna firma digitale o valore MAC incluso

## <a name="refreshing-jwts"></a>Aggiornamento di token JWT

Prima di tutto, è consigliabile considerare attentamente l'eventualità che l'aggiornamento automatico di un token JWT possa introdurre vulnerabilità nel sistema.

L'operazione non è inclusa nella libreria, tuttavia è possibile consultare [questo esempio](https://gist.github.com/ziluvatar/a3feb505c4c0ec37059054537b38fc48) per informazioni su come eseguire questa operazione.
Oltre a questo esempio sono disponibili [un problema](https://github.com/auth0/node-jsonwebtoken/issues/122) e [una richiesta pull](https://github.com/auth0/node-jsonwebtoken/pull/172) per ottenere maggiori informazioni sull'argomento.

# <a name="todo"></a>TODO

* La catena di certificati X.509 non è selezionata

## <a name="issue-reporting"></a> Comunicazione di problemi 

Se si trova un bug o si desidera presentare una richiesta di funzionalità, segnalarli nella sezione relativa ai problemi del repository. Non segnalare le vulnerabilità di sicurezza nel tracker pubblico dei problemi di GitHub. Il [Responsible Disclosure Program](https://auth0.com/whitehat) illustra in dettaglio la procedura per la divulgazione di problemi di sicurezza.

## <a name="author"></a>Autore

[Auth0](https://auth0.com)

## <a name="license"></a>Licenza

Questo progetto è concesso in licenza secondo i termini della licenza MIT. Per ulteriori informazioni, vedere il file [LICENSE](LICENSE).
